# -*- coding: utf-8 -*-
# b_test_based.py
import streamlit as st
from pathlib import Path
from PIL import Image
import uuid, re, os, json, copy, shutil, time, traceback, hashlib
import base64
from moviepy.editor import AudioFileClip, concatenate_audioclips, VideoFileClip, concatenate_videoclips, vfx, ImageClip
from moviepy.video.fx.all import crop
from openai import OpenAI
from datetime import datetime


client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
from difflib import SequenceMatcher

# ì™¸ë¶€ ëª¨ë“ˆ ì„í¬íŠ¸ (app.pyì™€ ë™ì¼í•œ ìœ„ì¹˜ì— ìˆë‹¤ê³  ê°€ì •)
from runway_api import generate_video_from_image, extract_video_url
from video_utils import (
    download_video, 
    add_subtitle_to_video, 
    trim_video_to_duration  
)

# 1. API í†µì‹ /ìƒì„±ì„ ë‹´ë‹¹í•˜ëŠ” í•¨ìˆ˜ëŠ” moduleì—ì„œ
from tts_module import generate_audio_for_subtitles

# 2. íŒŒì¼ ì¡°ì‘/ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ëŠ” coreì—ì„œ
from tts_core import (
    add_audio_to_video, 
    concat_videos_with_audio, 
    get_audio_duration
)


# --------------------------------
# 1. Bëª¨ë“œ ì „ìš© í—¬í¼ í•¨ìˆ˜ë“¤ ëª¨ìŒ
# --------------------------------

# --------------------------------
# BGM ê´€ë ¨ í•¨ìˆ˜
# --------------------------------
def get_bgm_folder_name(full_name: str) -> str:
    """BGM í´ë” ì•ˆì˜ í•˜ìœ„ í´ë”ëª…ê³¼ ìœ ì‚¬ë„ ë¹„êµí•˜ì—¬ ê°€ì¥ ì¼ì¹˜í•˜ëŠ” í´ë”ëª… ë°˜í™˜"""
    bgm_root = Path("BGM")
    if not bgm_root.exists():
        return full_name

    # BGM í´ë” ë‚´ í•˜ìœ„ í´ë” ëª©ë¡
    bgm_folders = [f.name for f in bgm_root.iterdir() if f.is_dir()]
    if not bgm_folders:
        return full_name

    # ë¹„êµìš©: ê³µë°±/ì–¸ë”ìŠ¤ì½”ì–´ ì œê±°í•œ ì…ë ¥ê°’
    normalized_input = full_name.replace(" ", "").replace("_", "")

    # 1ì°¨: ë¶€ë¶„ ë¬¸ìì—´ ë§¤ì¹­ (í´ë”ëª…ì´ ì…ë ¥ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€)
    for folder in bgm_folders:
        normalized_folder = folder.replace(" ", "").replace("_", "")
        if normalized_folder in normalized_input or normalized_input in normalized_folder:
            return folder

    # 2ì°¨: SequenceMatcher ìœ ì‚¬ë„ ë¹„êµ
    best_match = None
    best_ratio = 0.0
    for folder in bgm_folders:
        normalized_folder = folder.replace(" ", "").replace("_", "")
        ratio = SequenceMatcher(None, normalized_input, normalized_folder).ratio()
        if ratio > best_ratio:
            best_ratio = ratio
            best_match = folder

    if best_match and best_ratio >= 0.4:
        return best_match

    return full_name

def get_bgm_for_page(page_name: str, bgm_dir: Path):
    """í˜ì´ì§€ ì´ë¦„ì—ì„œ ë²ˆí˜¸ë¥¼ ì¶”ì¶œí•˜ì—¬ í•´ë‹¹í•˜ëŠ” BGM íŒŒì¼ ì°¾ê¸°"""
    if not bgm_dir.exists():
        return None

    # íŒŒì¼ëª…ì—ì„œ í˜ì´ì§€ ë²ˆí˜¸ ì¶”ì¶œ (ì˜ˆ: "page_11" -> 11)
    match = re.search(r"page_(\d+)", page_name)
    if not match:
        return None
    page_num = int(match.group(1))

    # BGM í´ë”ì—ì„œ í•´ë‹¹ í˜ì´ì§€ ë²ˆí˜¸ì˜ íŒŒì¼ ì°¾ê¸°
    for bgm_file in bgm_dir.iterdir():
        if bgm_file.suffix.lower() not in ['.wav', '.mp3', '.m4a']:
            continue
        # íŒ¨í„´1: _ìˆ«ìP (ì˜ˆ: _11Pìˆ˜ì •.wav)
        bgm_match = re.search(r'_(\d+)P', bgm_file.name)
        if bgm_match and int(bgm_match.group(1)) == page_num:
            return bgm_file
        # íŒ¨í„´2: Page ìˆ«ì (ì˜ˆ: _Page 11.m4a)
        bgm_match = re.search(r'Page\s*(\d+)', bgm_file.name)
        if bgm_match and int(bgm_match.group(1)) == page_num:
            return bgm_file
    return None
# --------------------------------
# B. íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ í•¨ìˆ˜
# --------------------------------
def extract_title_from_filename(filename: str) -> str:
    """
    íŒŒì¼ëª… ê·œì¹™: xxxx_xxê°œì›”_ë‚´ì§€_(ì œëª©)_xx_xxxx.txt
    'ë‚´ì§€_' ë’¤ì— ì˜¤ëŠ” ë¬¸ìì—´ì„ ì œëª©ìœ¼ë¡œ ì¶”ì¶œí•©ë‹ˆë‹¤.
    """
    # 'ë‚´ì§€_' ë’¤ì— ì˜¤ëŠ” ë‚´ìš©ë¶€í„°, ê·¸ ë‹¤ìŒ '_'ê°€ ë‚˜ì˜¤ê¸° ì „ê¹Œì§€ ì¶”ì¶œ
    pattern = r"ë‚´ì§€_(.*?)_"
    match = re.search(pattern, filename)
    
    if match:
        return match.group(1)
    
    # íŒ¨í„´ ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ íŒŒì¼ëª… ìì²´ë¥¼ ë°˜í™˜ (í™•ì¥ì ì œì™¸)
    return Path(filename).stem


# --------------------------------
# B. [Step 1 Helper] ë™í™” í…ìŠ¤íŠ¸ ë¶„ì„ í•¨ìˆ˜
# --------------------------------
def analyze_story_structure(full_text: str, known_title: str = ""):
    """
    GPTë¥¼ í†µí•´ ë™í™”ì˜ ì „ì²´ ë‚´ìš©ì„ ë¶„ì„í•©ë‹ˆë‹¤. (íŒŒì¼ëª…ì—ì„œ ì¶”ì¶œí•œ ì œëª© ì°¸ê³ )
    """
    system_prompt = f"""
    ë‹¹ì‹ ì€ ë™í™” ë¶„ì„ ë° ì˜ˆê³ í¸ ê¸°íš ì „ë¬¸ê°€ì…ë‹ˆë‹¤. 
    ì£¼ì–´ì§„ ë™í™” í…ìŠ¤íŠ¸ë¥¼ ì •ë°€í•˜ê²Œ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ í•­ëª©ì„ JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•˜ì„¸ìš”.
    
    [ë¶„ì„ ìš”êµ¬ì‚¬í•­]
    1. title: ë™í™”ì˜ ì œëª© (ì œê³µëœ ì œëª© '{known_title}'ì„ ìµœìš°ì„ ìœ¼ë¡œ ì‚¬ìš©í•˜ë˜, ë‚´ìš©ê³¼ ë§ì§€ ì•Šìœ¼ë©´ ìˆ˜ì •)
    2. summary: ì „ì²´ ì¤„ê±°ë¦¬ (ì˜ˆê³ í¸ êµ¬ì„±ì„ ìœ„í•´ ì‚¬ê±´ì˜ ì¸ê³¼ê´€ê³„ê°€ ë“œëŸ¬ë‚˜ë„ë¡ **4~8ë¬¸ì¥** ë¶„ëŸ‰ìœ¼ë¡œ ìƒì„¸í•˜ê²Œ ìš”ì•½)
    3. plot_structure: ì´ì•¼ê¸°ì˜ íë¦„ì„ 'ê¸°(ë°œë‹¨)-ìŠ¹(ì „ê°œ)-ì „(ìœ„ê¸°/ì ˆì •)-ê²°(ê²°ë§)' 4ë‹¨ê³„ë¡œ ë‚˜ëˆ„ì–´ ë¶„ì„.
       - **ì¤‘ìš”:** í…ìŠ¤íŠ¸ì— ìˆëŠ” `--- Page N ---` í‘œì‹œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê° ë‹¨ê³„ê°€ ì‹œì‘ë˜ëŠ” í˜ì´ì§€ì™€ ëë‚˜ëŠ” í˜ì´ì§€ë¥¼ ì •í™•íˆ ëª…ì‹œí•  ê²ƒ.
       - ê° ë‹¨ê³„ëŠ” ë‹¨ìˆœ ìš”ì•½ì´ ì•„ë‹ˆë¼, **ì£¼ìš” ì‚¬ê±´, ê°ˆë“±ì˜ ì‹¬í™”, ê°ì •ì˜ ë³€í™”**ê°€ ì¶©ë¶„íˆ ë“œëŸ¬ë‚˜ë„ë¡ ìƒì„¸í•˜ê²Œ ì„œìˆ í•  ê²ƒ. **4~8ë¬¸ì¥** ë¶„ëŸ‰ìœ¼ë¡œ ìƒì„¸í•˜ê²Œ ìš”ì•½. ì›ë¬¸ì„ ë°”íƒ•ìœ¼ë¡œ ì›ë¬¸ê³¼ ë¹„ìŠ·í•œ ì–‘ìƒìœ¼ë¡œ ì„œìˆ í•  ê²ƒ.
    4. moral: ì´ ë™í™”ê°€ ì£¼ëŠ” êµí›ˆì´ë‚˜ ë©”ì‹œì§€
    5. key_scenes: ì˜ˆê³ í¸ì— ë„£ìœ¼ë©´ ì¢‹ì„ë§Œí¼ ì‹œê°ì /ì²­ê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ í•µì‹¬ ì¥ë©´ 3~5ê°œ ì¶”ì²œ
    
    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "title": "...",
        "summary": "...",
        "plot_structure": {{
            "introduction": {{
                "summary": "ë‚´ìš© ìš”ì•½...",
                "start_page": 1,
                "end_page": 5
            }},
            "development": {{
                "summary": "ë‚´ìš© ìš”ì•½...",
                "start_page": 6,
                "end_page": 15
            }},
            "climax": {{
                "summary": "ë‚´ìš© ìš”ì•½...",
                "start_page": 16,
                "end_page": 22
            }},
            "resolution": {{
                "summary": "ë‚´ìš© ìš”ì•½...",
                "start_page": 23,
                "end_page": 30
            }}
        }},
        "moral": "...",
        "key_scenes": ["...", "..."]
    }}
    """
    
    response = client.chat.completions.create(
        model="gpt-5.2",  # ìƒì„¸ ë¶„ì„ì„ ìœ„í•´ ê³ ì„±ëŠ¥ ëª¨ë¸ ê¶Œì¥
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": f"ë‹¤ìŒ ë™í™” ë‚´ìš©ì„ ë¶„ì„í•´ì£¼ì„¸ìš”:\n\n{full_text}"}
        ],
        response_format={"type": "json_object"}
    )
    
    return json.loads(response.choices[0].message.content)

VOICE_TYPES = [
    "child_male",
    "child_female",
    "child_bright",
    "young_male",
    "young_female",
    "adult_male",
    "adult_male_deep",
    "adult_female",
    "elder_male",
    "elder_female",
    "cute_animal",
    "dog",
    "demon",
    "robot",
    "fairy",
    "narrator"
]

# --------------------------------
# [Step 1.5 Helper] ìºë¦­í„° ë° í™”ì ë¶„ì„ 
# --------------------------------
def analyze_characters_and_speakers(client, full_text: str):
    """
    ë™í™” í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ë“±ì¥ì¸ë¬¼ í”„ë¡œí•„ê³¼ ëŒ€ì‚¬-í™”ì-í˜ì´ì§€ ë§¤í•‘ ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
    """
    # GPTì—ê²Œ ì„ íƒì§€ë¡œ ì¤„ ëª©ì†Œë¦¬ íƒ€ì… ëª©ë¡
    voice_options = """
    - child_male (ë‚¨ì ì•„ì´)
    - child_female (ì—¬ì ì•„ì´)
    - child_bright (ëª…ë‘í•œ ì•„ì´)
    - young_male (ì²­ë…„ ë‚¨ì„±)
    - young_female (ì²­ë…„ ì—¬ì„±)
    - adult_male (ì„±ì¸ ë‚¨ì„± - ì¼ë°˜)
    - adult_male_deep (ì„±ì¸ ë‚¨ì„± - êµµê³  ë‚®ì€/ìœ„ì—„ìˆëŠ”/í˜¸ë‘ì´/ì™•)
    - adult_female (ì„±ì¸ ì—¬ì„±)
    - elder_male (í• ì•„ë²„ì§€/ë…¸ì¸)
    - elder_female (í• ë¨¸ë‹ˆ/ë…¸ì¸)
    - cute_animal (ê·€ì—¬ìš´ ë™ë¬¼ - ê³ ì–‘ì´, í† ë¼ ë“±)
    - dog (ê°•ì•„ì§€/ê°œ)
    - demon (ì•…ë§ˆ/ê´´ë¬¼)
    - robot (ë¡œë´‡/ê¸°ê³„)
    - fairy (ìš”ì •/ì‹ ë¹„ë¡œì›€)
    - narrator (í•´ì„¤ì)
    """
    system_prompt = """
    ë‹¹ì‹ ì€ ì†Œì„¤ ë° ë™í™” ë¶„ì„ ì „ë¬¸ê°€ì´ì ì„±ìš° ìºìŠ¤íŒ… ë””ë ‰í„°ì…ë‹ˆë‹¤.
    ì œê³µëœ í…ìŠ¤íŠ¸ì—ëŠ” `--- Page N ---` í˜•ì‹ìœ¼ë¡œ í˜ì´ì§€ ë²ˆí˜¸ê°€ êµ¬ë¶„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
    ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ì •ë³´ë¥¼ JSONìœ¼ë¡œ ë°˜í™˜í•˜ì„¸ìš”.

    1. **characters (ë“±ì¥ì¸ë¬¼ í”„ë¡œí•„)**
       - ë“±ì¥í•˜ëŠ” ëª¨ë“  ìºë¦­í„°ì˜ ì´ë¦„, ì„±ë³„, ì—°ë ¹ëŒ€, ì–´ì¡°ë¥¼ ì •ë¦¬í•˜ê³  ë¶„ì„í•´ **ê°€ì¥ ì–´ìš¸ë¦¬ëŠ” ëª©ì†Œë¦¬ íƒ€ì…(voice_type)**ì„ ì§€ì •í•˜ì„¸ìš”.
       - ë™ì¼ ì¸ë¬¼ì˜ ë‹¤ë¥¸ í˜¸ì¹­(aliases)ì„ ë¬¶ì–´ì„œ í•˜ë‚˜ì˜ IDë¡œ ê´€ë¦¬í•˜ì„¸ìš”.

    [ë°˜í™˜ ë°ì´í„° êµ¬ì¡° (JSON)]
    1. **characters (ë“±ì¥ì¸ë¬¼ í”„ë¡œí•„)**
       - `id`: ìºë¦­í„° ê³ ìœ  ID (ì˜ˆ: char_01)
       - `name`: ì´ë¦„
       - `gender`: Male / Female : ì„±ë³„ì„ í•˜ë‚˜ ì„ íƒí•´ì•¼í•˜ë©° í…ìŠ¤íŠ¸ì—ì„œ ëª…í™•í•˜ê²Œ ë¬˜ì‚¬ë˜ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” ëŒ€í™”ë¬¸, ì„œì‚¬ì  ì–‘ìƒìœ¼ë¡œ ì„±ë³„ì„ ê²°ì •í•´ì•¼í•¨.
       - `age_group`: Child / Young / Adult / Elder
       - `tone`: ì„±ê²©ì´ë‚˜ ë§íˆ¬ ë¬˜ì‚¬
       - `voice_type`: **ì•„ë˜ ì œê³µëœ [Voice List] ì¤‘ ìºë¦­í„°ì—ê²Œ ê°€ì¥ ì˜ ì–´ìš¸ë¦¬ëŠ” í‚¤ì›Œë“œ 1ê°œë¥¼ ì„ íƒí•˜ë©° **í‚¤ì›Œë“œë¥¼ ë³€í˜•í•˜ì§€ ì•ŠìŒ** (í•„ìˆ˜)**
    
    [Voice List (ì•„ë˜ voice_options ì—¬ê¸°ì„œë§Œ ì„ íƒí•  ê²ƒ, ìˆ˜ì •í•˜ê±°ë‚˜ ì„¤ëª…ì„ ì¶”ê°€í•˜ì§€ ì•ŠìŒ)]
    {voice_options}

    2. **dialogue_map (ëŒ€ì‚¬ ì •ë°€ ë¶„ì„)**
       - í…ìŠ¤íŠ¸ ë‚´ì˜ **ëª¨ë“  ëŒ€í™”ë¬¸("")**ì„ ìˆœì„œëŒ€ë¡œ ì¶”ì¶œí•˜ì„¸ìš”. `context`ë¥¼ ë‹¤ìŒ ê·œì¹™ì— ë”°ë¼ ì‘ì„±í•˜ì„¸ìš”.
       - `speaker_id`: ëˆ„ê°€ ë§í–ˆëŠ”ì§€ ì‹ë³„í•˜ì„¸ìš”.
       - `page_num`: **í•´ë‹¹ ëŒ€ì‚¬ê°€ ëª‡ í˜ì´ì§€(Page N)ì— ìˆëŠ”ì§€ ì •í™•í•œ ì •ìˆ˜(Int)ë¡œ ì ìœ¼ì„¸ìš”.** (ë§¤ìš° ì¤‘ìš”)

    â­â­ **`context` ì‘ì„± ì ˆëŒ€ ê·œì¹™ (Context Writing Rules)** â­â­
    1. **ì—­í• **: ì´ ìë§‰ì€ ëŒ€ì‚¬ê°€ ì˜¤ë””ì˜¤ë¡œ ë‚˜ì˜¬ ë•Œ, **í™”ë©´ì˜ ìƒí™©ì„ ì„¤ëª…í•´ì£¼ëŠ” í•´ì„¤ ìë§‰**ì…ë‹ˆë‹¤.
    2. **ë‚´ìš©**: ëŒ€ì‚¬ë¥¼ ë‹¨ìˆœíˆ ìš”ì•½í•˜ê±°ë‚˜ ë°˜ë³µí•˜ì§€ ë§ˆì„¸ìš”. (ì˜ˆ: "~ê°€ ë§í–ˆë‹¤" ê¸ˆì§€)
       ëŒ€ì‹ , **ê·¸ ëŒ€ì‚¬ë¥¼ í•  ë•Œ ìºë¦­í„°ê°€ ì·¨í•œ í–‰ë™**ì´ë‚˜, **ê·¸ ëŒ€ì‚¬ë¥¼ ìœ ë°œí•œ ì‹œê°ì  ìƒí™©**ì„ ë¬˜ì‚¬í•˜ì„¸ìš”.
    3. **ìƒí˜¸ë³´ì™„ì„±**: 
       - ëŒ€ì‚¬ê°€ í–‰ë™ì„ ì§€ì‹œí•˜ë©´ -> `context`ëŠ” ê·¸ í–‰ë™ì´ ì´ë£¨ì–´ì§€ëŠ” ëª¨ìŠµì„ ë¬˜ì‚¬.
       - ëŒ€ì‚¬ê°€ ê°íƒ„/ë°œê²¬ì´ë©´ -> `context`ëŠ” ë¬´ì—‡ì„ ë³´ì•˜ëŠ”ì§€ ì‹œê°ì ìœ¼ë¡œ ë¬˜ì‚¬.
    4. **ë¬¸ì²´**: ì–´ë¦°ì´ ë™í™”ì±…ì˜ **ì§€ë¬¸(Narration)**ì²˜ëŸ¼ ë¶€ë“œëŸ¬ìš´ 'í•´ìš”ì²´' ë˜ëŠ” 'í•©ì‡¼ì²´' ë¬¸ì¥ìœ¼ë¡œ ì“°ì„¸ìš”.

    [ì‘ì„± ì˜ˆì‹œ]
    - (Case A: í–‰ë™ ë¬˜ì‚¬)
      Quote: "ì½©ì¥ì•¼, ë‚´ê°€ êµ¬ë©ì„ ë§‰ì•„ì¤„ í…Œë‹ˆ ë¬¼ì„ ì±„ìš°ë ´."
      Context: "ë‘êº¼ë¹„ê°€ ìš¸í‰ë¶ˆí‰í•œ ëª¸ìœ¼ë¡œ ë…ì˜ êµ¬ë© ë‚œ ë¶€ë¶„ì„ ê½‰ ë§‰ì•„ì£¼ì—ˆì–´ìš”." (O)
      Context: "ë‘êº¼ë¹„ê°€ ì½©ì¥ì—ê²Œ êµ¬ë©ì„ ë§‰ì•„ì¤€ë‹¤ê³  ë§í–ˆì–´ìš”." (X - ë‹¨ìˆœ ë°˜ë³µ)

    - (Case B: ì‹œê°ì  ìƒí™©)
      Quote: "ì €ê¸° í™˜í•˜ê²Œ ë¹›ë‚˜ëŠ” ê²ƒì´ ë¬´ì—‡ì¸ì§€ ì•Œì•„ë³´ì•„ë¼."
      Context: "ìˆ˜í’€ ì†ì— ìˆ¨ì–´ìˆëŠ” ë¹›ë‚˜ëŠ” ê°ì‹œë¥¼ ë°œê²¬í•˜ê³  ì›ë‹˜ì´ ì†Œë¦¬ì³¤ì–´ìš”." (O)
      Context: "ì›ë‹˜ì´ ì €ê²Œ ë­ëƒê³  ë¬¼ì–´ë´¤ì–´ìš”." (X - ë‹¨ìˆœ ìš”ì•½)

    [ë°˜í™˜ í˜•ì‹ - JSON]
    {
        "characters": [
            {
                "id": "char_01",
                "name": "í¥ë¶€",
                "aliases": ["í¥ë¶€", "ë™ìƒ"],
                "gender": "Male",
                "age_group": "Young",
                "tone": "ê³µì†í•˜ê³  ì£¼ëˆ… ë“  ëª©ì†Œë¦¬",
                "visual": "í—ˆë¦„í•œ ì˜·ì°¨ë¦¼",
                "voice_type": "young_male"
            }
        ],
        "dialogue_map": [
            {
                "quote": "í˜•ë‹˜, ìŒ€ ì¢€ ê¾¸ì–´ì£¼ì„¸ìš”.", 
                "speaker_id": "char_01", 
                "page_num": 8,
                "context": "í¥ë¶€ê°€ ë†€ë¶€ ì§‘ì„ ì°¾ì•„ê°€ ë¶€íƒí–ˆì–´ìš”."
            },
            {
                "quote": "ë‹¹ì¥ ë‚˜ê°€ì§€ ëª»í•´!", 
                "speaker_id": "char_02", 
                "page_num": 9,
                "context": "ë†€ë¶€ê°€ í¥ë¶€ë¥¼ ë°¥ì£¼ê±±ìœ¼ë¡œ ë•Œë ¸ì–´ìš”."
            }
        ]
    }
    """

    response = client.chat.completions.create(
        model="gpt-5.2",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": full_text}
        ],
        response_format={
            "type": "json_schema",
            "json_schema": {
                "name": "character_and_dialogue_analysis",
                "schema": {
                    "type": "object",
                    "required": ["characters", "dialogue_map"],
                    "properties": {
                        "characters": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "required": [
                                    "id",
                                    "name",
                                    "aliases",
                                    "gender",
                                    "age_group",
                                    "tone",
                                    "voice_type"
                                ],
                                "properties": {
                                    "id": { "type": "string" },
                                    "name": { "type": "string" },
                                    "aliases": {
                                        "type": "array",
                                        "items": { "type": "string" }
                                    },
                                    "gender": {
                                        "type": "string",
                                        "enum": ["Male", "Female"]
                                    },
                                    "age_group": {
                                        "type": "string",
                                        "enum": ["Child","Young", "Adult", "Elder"]
                                    },
                                    "tone": { "type": "string" },
                                    "voice_type": {
                                        "type": "string",
                                        "enum": VOICE_TYPES
                                    }
                                }
                            }
                        },
                        "dialogue_map": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "required": [
                                    "quote",
                                    "speaker_id",
                                    "page_num",
                                    "context"
                                ],
                                "properties": {
                                    "quote": { "type": "string" },
                                    "speaker_id": { "type": "string" },
                                    "page_num": { "type": "integer" },
                                    "context": { "type": "string" }
                                }
                            }
                        }
                    }
                }
            }
        }
    )
    
    return json.loads(response.choices[0].message.content)

GPT_VOICE_TO_UI_LABEL = {
    # ì•„ë™
    "child_male": "ğŸ‘¦ ì•„ë™ ë‚¨ì„± (í•˜ì¤€)",
    "child_female": "ğŸ‘§ ì•„ë™ ì—¬ì„± (ë‹¤ì¸)",
    "child_bright": "ğŸ‘§ ì•„ë™ ì—¬ì„± (ê°€ëŒ - ë°ìŒ)",
    
    # ì²­ë…„
    "young_male": "ğŸ‘± ì²­ë…„ ë‚¨ì„± (ì€ìš°)",
    "young_female": "ğŸ‘© ì²­ë…„ ì—¬ì„± (ì•„ë¼)",
    
    # ì„±ì¸
    "adult_male": "ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ë¯¼ìƒ - ë‰´ìŠ¤í†¤)",
    "adult_male_deep": "ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ì›íƒ - êµµê³  ë‚®ìŒ)",
    "adult_female": "ğŸ‘© ì„±ì¸ ì—¬ì„± (ì˜ˆì§„ - ì°¨ë¶„í•¨)",
    
    # ë…¸ì¸
    "elder_male": "ğŸ‘´ ì–´ë¥´ì‹  ë‚¨ì„± (ì¢…í˜„)",
    "elder_female": "ğŸ‘µ ì–´ë¥´ì‹  ì—¬ì„± (ì„ í¬)",
    
    # íŠ¹ìˆ˜
    "cute_animal": "ğŸ± ê³ ì–‘ì´/ë™ë¬¼ (ì•¼ì˜¹ì´)",
    "dog": "ğŸ¶ ê°•ì•„ì§€ (ë©ë©ì´)",
    "demon": "ğŸ˜ˆ ì•…ë§ˆ/ê´´ë¬¼ (ë§ˆëª¬)",
    "robot": "ğŸ¤– ë¡œë´‡/ê¸°ê³„ (ì›íƒ)",
    "fairy": "ğŸ§š ìš”ì • (ì‹ ìš° - ì¤‘ì„±ì )",
    "narrator": "ğŸ‘© ì„±ì¸ ì—¬ì„± (ì§€ìœ¤ - ë‚˜ë ˆì´ì…˜)"
}

# 2. VOICE_PRESETS (UI í‘œì‹œìš© -> ì‹¤ì œ Clova ID)
# (ì´ì „ ë‹µë³€ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€)
VOICE_PRESETS = {
    "--- ìë™/ê¸°ë³¸ê°’ ---": None,
    "ğŸ‘¦ ì•„ë™ ë‚¨ì„± (í•˜ì¤€)": "nhajun",
    "ğŸ‘¦ ì•„ë™ ë‚¨ì„± (ì¬ìš±)": "njaewook",
    "ğŸ‘§ ì•„ë™ ì—¬ì„± (ë‹¤ì¸)": "ndain",
    "ğŸ‘§ ì•„ë™ ì—¬ì„± (ê°€ëŒ - ë°ìŒ)": "ngaram",
    "ğŸ‘± ì²­ë…„ ë‚¨ì„± (ì€ìš°)": "neunwoo",
    "ğŸ‘± ì²­ë…„ ë‚¨ì„± (ì§€í›ˆ)": "njihun",
    "ğŸ‘© ì²­ë…„ ì—¬ì„± (ì•„ë¼)": "nara",
    "ğŸ‘© ì²­ë…„ ì—¬ì„± (ìœ ì§„)": "nyujin",
    "ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ë¯¼ìƒ - ë‰´ìŠ¤í†¤)": "nminsang",
    "ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ì¤€ì˜ - ë¶€ë“œëŸ¬ì›€)": "njoonyoung",
    "ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ì›íƒ - êµµê³  ë‚®ìŒ)": "nwontak",
    "ğŸ‘© ì„±ì¸ ì—¬ì„± (ì˜ˆì§„ - ì°¨ë¶„í•¨)": "nyejin",
    "ğŸ‘© ì„±ì¸ ì—¬ì„± (ì˜ë¯¸ - ë”°ëœ»í•¨)": "nyoungmi",
    "ğŸ‘© ì„±ì¸ ì—¬ì„± (ì§€ìœ¤ - ë‚˜ë ˆì´ì…˜)": "njiyun",
    "ğŸ‘´ ì–´ë¥´ì‹  ë‚¨ì„± (ì¢…í˜„)": "njonghyun",
    "ğŸ‘µ ì–´ë¥´ì‹  ì—¬ì„± (ì„ í¬)": "nsunhee",
    "ğŸ± ê³ ì–‘ì´/ë™ë¬¼ (ì•¼ì˜¹ì´)": "nmeow",
    "ğŸ¶ ê°•ì•„ì§€ (ë©ë©ì´)": "nwoof",
    "ğŸ˜ˆ ì•…ë§ˆ/ê´´ë¬¼ (ë§ˆëª¬)": "nmammon",
    "ğŸ¤– ë¡œë´‡/ê¸°ê³„ (ì›íƒ)": "nwontak",
    "ğŸ§š ìš”ì • (ì‹ ìš° - ì¤‘ì„±ì )": "nsinu",
}
# --------------------------------
# [Step 2 Helper] ì˜ˆê³ í¸ êµ¬ê°„ í™•ì¸
# --------------------------------

# --------------------------------
# [Step 2 Helper] ì˜ˆê³ í¸ êµ¬ê°„ ì¶”ì²œ í•¨ìˆ˜ (í”„ë¡¬í”„íŠ¸ ê°•í™”íŒ)
# --------------------------------
def recommend_trailer_segments(full_text: str, analysis_data: dict):
    """
    GPTì—ê²Œ ì „ì²´ í…ìŠ¤íŠ¸ì™€ ë¶„ì„ ë°ì´í„°ë¥¼ ì£¼ê³ , ì˜ˆê³ í¸ìœ¼ë¡œ ì“°ê¸° ì¢‹ì€ 3ê°€ì§€ êµ¬ê°„ì„ ì¶”ì²œë°›ìŠµë‹ˆë‹¤.
    (ì¡°ê±´: ì´ˆë°˜ ë„ì…ë¶€ ë°°ì œ + ì¤‘~í›„ë°˜ë¶€ ìœ„ê¸°/ì ˆì • ì§ì „ ì§‘ì¤‘ + ê²°ë§ ì ˆëŒ€ ë°°ì œ)
    """
    
    # 1ë‹¨ê³„ì—ì„œ ë¶„ì„í•œ ê¸°ìŠ¹ì „ê²° ì •ë³´ í™œìš©
    structure = analysis_data.get("plot_structure", {})
    summary = analysis_data.get("summary", "")
    
    system_prompt = f"""
    ë‹¹ì‹ ì€ ê´€ê°ì˜ ì• ë¥¼ íƒœìš°ëŠ” 'ì•…ë§ˆì˜ ì˜ˆê³ í¸ í¸ì§‘ì'ì…ë‹ˆë‹¤.
    ì „ì²´ ë™í™” í…ìŠ¤íŠ¸ ì¤‘ì—ì„œ ê°€ì¥ ê¸´ë°•í•˜ê³  í˜¸ê¸°ì‹¬ì„ ìê·¹í•˜ëŠ” **í•˜ì´ë¼ì´íŠ¸ êµ¬ê°„(300~600ì)** 3ê°€ì§€ë¥¼ ì°¾ìœ¼ì„¸ìš”.

    [ğŸ¯ ìœ„ì¹˜ ì„ ì • ê·œì¹™ (ë§¤ìš° ì¤‘ìš”)]
    1. **ì´ˆë°˜ë¶€(Introduction) ë°°ì œ**: "ì˜›ë‚  ì˜›ì ì—..."ì™€ ê°™ì€ í‰í™”ë¡œìš´ ë°°ê²½ ì„¤ëª…ì´ë‚˜ ìºë¦­í„° ì†Œê°œ ë¶€ë¶„ì€ ì“°ì§€ ë§ˆì„¸ìš”. ì§€ë£¨í•©ë‹ˆë‹¤.
    2. **ì¤‘~í›„ë°˜ë¶€ ì§‘ì¤‘**: ì‚¬ê±´ì´ ì´ë¯¸ ë²Œì–´ì§€ê³ , ê°ˆë“±ì´ ì‹¬í™”ë˜ëŠ” **'ì „ê°œ(Development)'ì—ì„œ 'ìœ„ê¸°/ì ˆì •(Climax)' ì§ì „** ì‚¬ì´ì˜ êµ¬ê°„ì„ ì„ íƒí•˜ì„¸ìš”.
    3. **ì´ë¯¸ ì§„í–‰ëœ ìƒí™©**: ì£¼ì¸ê³µì´ ì´ë¯¸ ëª¨í—˜ì„ ë– ë‚¬ê±°ë‚˜, ì•…ë‹¹ì„ ë§Œë‚¬ê±°ë‚˜, ê³¤ë€í•œ ìƒí™©ì— ë¹ ì ¸ ìˆëŠ” ì‹œì ì´ì–´ì•¼ í•©ë‹ˆë‹¤.

    [â›” ì ˆëŒ€ ê¸ˆì§€ ì‚¬í•­]
    1. **ê²°ë§(Resolution) í¬í•¨ ê¸ˆì§€**: ëª¨ë“  ê°ˆë“±ì´ í•´ê²°ë˜ê±°ë‚˜ í–‰ë³µí•œ ê²°ë§ì´ ë‚˜ì˜¤ëŠ” ë¶€ë¶„ì€ ì ˆëŒ€ í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”.
    2. **ë‹¨ìˆœ ë‚˜ì—´ ê¸ˆì§€**: ì‚¬ê±´ì˜ ì¸ê³¼ê´€ê³„ ì—†ì´ ì¥ë©´ë§Œ ë‚˜ì—´í•˜ì§€ ë§ê³ , í•˜ë‚˜ì˜ ê¸´ë°•í•œ íë¦„ì´ ìˆëŠ” ë©ì–´ë¦¬ í…ìŠ¤íŠ¸ë¥¼ ë°œì·Œí•˜ì„¸ìš”.

    [âœ‚ï¸ í¸ì§‘ í¬ì¸íŠ¸: ì ˆë‹¨ì‹ ê³µ]
    - í…ìŠ¤íŠ¸ì˜ ëë¶€ë¶„ì€ ë°˜ë“œì‹œ ì£¼ì¸ê³µì´ **ìµœëŒ€ ìœ„ê¸°ì— ì²˜í•˜ê±°ë‚˜, ì¶©ê²©ì ì¸ ì‚¬ì‹¤ì„ ì•Œê²Œ ë˜ëŠ” ìˆœê°„**ì—ì„œ ë”± ëŠì–´ì•¼ í•©ë‹ˆë‹¤.
    - ì‹œì²­ìê°€ "ë„ëŒ€ì²´ ì–´ë–»ê²Œ ë˜ëŠ” ê±°ì•¼?"ë¼ê³  ì†Œë¦¬ì¹˜ê²Œ ë§Œë“œì„¸ìš”.

    [êµ¬ê°„ ì¶”ì¶œ(target_text) ê·œì¹™]
    -êµ¬ê°„ì„ ì¶”ì¶œí•  ë•Œ(target_text), ì›ë¬¸ì— ìˆëŠ” í˜ì´ì§€ í‘œì‹œ(ì˜ˆ: --- Page 19 ---)ë¥¼ ì ˆëŒ€ ì‚­ì œí•˜ì§€ ë§ê³  í¬í•¨í•´ì„œ ì¶œë ¥í•´ì¤˜. ì›ë¬¸ ê·¸ëŒ€ë¡œ ì¸ìš©í•´ì•¼ í•´.

    [3ê°€ì§€ ì¶”ì²œ ì˜µì…˜]
    - ì˜µì…˜ 1 (Main Stream): ì´ì•¼ê¸°ì˜ ê°€ì¥ í° ê°ˆë“±ì´ í­ë°œí•˜ê¸° ì§ì „ (ê°€ì¥ ì •ì„ì ì¸ ì˜ˆê³ í¸)
    - ì˜µì…˜ 2 (Character Crisis): ì£¼ì¸ê³µì´ ê°€ì¥ í° ì‹œë ¨ì´ë‚˜ ë”œë ˆë§ˆì— ë¹ ì§„ ìˆœê°„
    - ì˜µì…˜ 3 (Mystery/Horror): ë„ëŒ€ì²´ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì•Œ ìˆ˜ ì—†ëŠ” ê¸°ì´í•˜ê³  ê¸´ë°•í•œ ìƒí™©

    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "options": [
            {{
                "id": 1,
                "type": "Main Stream",
                "title": "(ê¸´ë°•í•¨ì„ ê°•ì¡°í•˜ëŠ” ì œëª©)",
                "reason": "ì‚¬ê±´ì´ í•œì°½ ì§„í–‰ëœ ì¤‘ë°˜ë¶€ë¡œ, ì£¼ì¸ê³µì´ ~í•œ ìƒí™©ì— ì²˜í•´ ìˆì–´ ëª°ì…ë„ê°€ ë†’ê³  ë‹¤ìŒ ë‚´ìš©ì„ ê¶ê¸ˆí•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.",
                "target_text": "\n--- Page 19 ---\në‹¤ìŒ ë‚ ì—ë„...\n(ì¤‘ëµ)\n--- Page 20 ---\nâ€œë‹¹í…ŒìŠ¤ë¥¼ ì—†ì•  ë²„ë ¸ìœ¼ë©´ ì¢‹ê² ì–´!â€...\n..."
            }},
            ...
        ]
    }}
    """

    user_content = f"""
    [ì´ì•¼ê¸° êµ¬ì¡° ì •ë³´]
    - ì¤„ê±°ë¦¬: {summary}
    - ê¸°ìŠ¹ì „ê²°: {structure}

    [ì „ì²´ í…ìŠ¤íŠ¸]
    {full_text}
    """

    response = client.chat.completions.create(
        model="gpt-5.2",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_content}
        ],
        response_format={"type": "json_object"}
    )
    
    return json.loads(response.choices[0].message.content)


# --------------------------------
# [Step 2~6 Helper] ìŠ¤í¬ì¼ëŸ¬ ë°©ì§€ (ìƒí•œì„  ê³„ì‚°)
# --------------------------------
def find_spoiler_limit_page(target_text: str, page_map: dict = None):
    """
    target_text ë‚´ë¶€ì— í¬í•¨ëœ '--- Page N ---' í˜•ì‹ì„ íŒŒì‹±í•˜ì—¬
    ë“±ì¥í•˜ëŠ” í˜ì´ì§€ ë²ˆí˜¸ ì¤‘ ê°€ì¥ í° ê°’ì„ ìŠ¤í¬ì¼ëŸ¬ ìƒí•œì„ ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
    (ëª…ì‹œëœ í˜ì´ì§€ íƒœê·¸ë¥¼ ìš°ì„  ì‚¬ìš©í•©ë‹ˆë‹¤.)
    """
    if not target_text:
        return 999

    # 1. ì •ê·œí‘œí˜„ì‹ìœ¼ë¡œ '--- Page ìˆ«ì ---' íŒ¨í„´ ì°¾ê¸°
    #    ì˜ˆ: "--- Page 30 ---", "---Page 31---" ë“± ê³µë°± ìœ ë™ì„± í—ˆìš©
    pattern = re.compile(r"---\s*Page\s*(\d+)\s*---", re.IGNORECASE)
    matches = pattern.findall(str(target_text))
    
    # 2. ë§¤ì¹­ëœ ìˆ«ìê°€ ì—†ìœ¼ë©´ ì •ë³´ê°€ ì—†ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼ -> ì „ì²´ í—ˆìš©(999)
    if not matches:
        return 999
    
    # 3. ì¶”ì¶œëœ ìˆ«ìë“¤ì„ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ìµœëŒ“ê°’(ê°€ì¥ ë’¤ìª½ í˜ì´ì§€) ì°¾ê¸°
    try:
        page_nums = [int(m) for m in matches]
        max_page = max(page_nums)
        # í¼ì¹¨ë©´ ì²˜ë¦¬ ë¡œì§
        # ì§ìˆ˜ í˜ì´ì§€(ì˜ˆ: 30)ì—ì„œ ëë‚¬ë‹¤ë©´, ê°™ì€ í¼ì¹¨ë©´ì˜ ì˜¤ë¥¸ìª½(31)ê¹Œì§€ëŠ” ìŠ¤í¬ì¼ëŸ¬ê°€ ì•„ë‹˜
        if max_page % 2 == 0:
            max_page += 1            
        return max_page
    except Exception:
        return 999
    
def trim_full_text_by_page(full_text: str, max_page: int) -> str:
    """
    full_textê°€ '--- Page N ---' ë¸”ë¡ë“¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤ê³  ê°€ì •í•˜ê³ ,
    max_page ì´í•˜ í˜ì´ì§€ë§Œ ë‚¨ê²¨ì„œ ë°˜í™˜.
    """
    if max_page is None or max_page >= 999:
        return full_text

    # íŒ¨í„´ì€ ìœ„ì™€ ë™ì¼í•˜ê²Œ ì ìš©
    pattern = re.compile(r"---\s*Page\s*(\d+)\s*---", re.IGNORECASE)
    matches = list(pattern.finditer(full_text))
    
    if not matches:
        return full_text

    out_chunks = []
    for i, m in enumerate(matches):
        pg = int(m.group(1))
        
        # í˜„ì¬ í˜ì´ì§€ í—¤ë”ì˜ ì‹œì‘ ìœ„ì¹˜
        start = m.start()
        # ë‹¤ìŒ í˜ì´ì§€ í—¤ë”ì˜ ì‹œì‘ ìœ„ì¹˜ (ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ ë)
        end = matches[i+1].start() if i+1 < len(matches) else len(full_text)

        # ìƒí•œì„  ì´í•˜ì¸ í˜ì´ì§€ë§Œ ì¶”ê°€
        if pg <= max_page:
            out_chunks.append(full_text[start:end])
        else:
            # í˜ì´ì§€ ìˆœì„œê°€ ë’¤ì£½ë°•ì£½ì¼ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ break í•˜ì§€ ì•Šê³  continue í•˜ëŠ” ê²ƒì´ ì•ˆì „í•  ìˆ˜ ìˆìœ¼ë‚˜,
            # ë³´í†µ ì±… ì „ì²´ í…ìŠ¤íŠ¸ëŠ” ìˆœì„œëŒ€ë¡œì´ë¯€ë¡œ, ë’¤ìª½ ë‚´ìš©ì„ ìë¥´ê¸° ìœ„í•´ break ì‚¬ìš© ê°€ëŠ¥.
            # (ì—¬ê¸°ì„œëŠ” ì•ˆì „í•˜ê²Œ ìˆœì°¨ì ì´ë¼ ê°€ì •í•˜ê³  breakë¥¼ ê±¸ê±°ë‚˜, 
            #  í˜¹ì‹œ ëª¨ë¥¼ ë’¤ì£½ë°•ì£½ ìˆœì„œë¥¼ ëŒ€ë¹„í•´ ìŠ¤í¬ì¼ëŸ¬ í˜ì´ì§€ë§Œ ê±´ë„ˆë›°ë ¤ë©´ continue ì‚¬ìš©)
            continue 

    return "".join(out_chunks).strip()

# --------------------------------
# [Step 3 Helper] ëŒ€í™”ë¬¸ ëŒ€ë³¸ ìŠ¤í¬ì¼ëŸ¬ ì œê±°
# --------------------------------
def trim_dialogue_map_by_page(dialogue_map: list, max_page: int) -> list:
    if max_page is None or max_page >= 999:
        return dialogue_map
    # page_numì´ ë¬¸ìì—´ì¼ ê²½ìš° ëŒ€ë¹„í•˜ì—¬ int ë³€í™˜
    return [d for d in dialogue_map if int(d.get("page_num", 0)) <= max_page]

# --------------------------------
# [Step 3 Helper] ì›”ë ¹ ì¶”ì¶œ ë° ëŒ€ë³¸ ìŠ¤í™ ê³„ì‚° í•¨ìˆ˜
# --------------------------------
def extract_age_from_filename(filename: str) -> int:
    """
    íŒŒì¼ëª…ì—ì„œ 'xxê°œì›”'ì˜ ìˆ«ìë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
    ì˜ˆ: 'EQ_048ê°œì›”_ë‚´ì§€_...' -> 48
    """
    pattern = r"(\d+)ê°œì›”"
    match = re.search(pattern, filename)
    if match:
        return int(match.group(1))
    return 0  # ì¶”ì¶œ ì‹¤íŒ¨ ì‹œ 0 ë°˜í™˜ (ê¸°ë³¸ê°’ ì²˜ë¦¬ìš©)

def get_recommendation_by_age(months: int):
    """
    ì›”ë ¹ì— ë”°ë¥¸ ì¶”ì²œ ì†ë„, í†¤, ê¸°ë³¸ ê¸¸ì´ ì˜µì…˜ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    if 48 <= months <= 72:
        return {
            "group": "ë¯¸ì·¨í•™ (4~6ì„¸)",
            "speed": "slow",
            "tone": "ì¹œì ˆí•˜ê³  ì‰¬ìš´ ì–´íˆ¬",
            "default_option": "Short"
        }
    elif 73 <= months <= 96:
        return {
            "group": "ì´ˆë“± ì €í•™ë…„ (7~8ì„¸)",
            "speed": "normal",
            "tone": "ìƒë™ê° ìˆê³  í˜¸ê¸°ì‹¬ì„ ìê·¹í•˜ëŠ” ì–´íˆ¬",
            "default_option": "Standard"
        }
    elif months >= 97:
        return {
            "group": "ì´ˆë“± ê³ í•™ë…„ (9ì„¸ ì´ìƒ)",
            "speed": "fast",
            "tone": "ë°•ì§„ê° ë„˜ì¹˜ê³  íŠ¸ë Œë””í•œ ì–´íˆ¬",
            "default_option": "Standard"
        }
    else:
        return {
            "group": "ì—°ë ¹ ë¯¸ìƒ",
            "speed": "normal",
            "tone": "í‘œì¤€ ë™í™” êµ¬ì—° ì–´íˆ¬",
            "default_option": "Standard"
        }
    

# --------------------------------
# [Step 3 Helper] ì¼ë°˜(Standard) ëŒ€ë³¸ ì‘ì„± í•¨ìˆ˜
# --------------------------------

def generate_script_with_specs(target_text: str, duration_opt: str, age_info: dict, full_text: str, char_info: dict):
    """
    ì „ì²´ ì›ë¬¸(full_text)ìœ¼ë¡œ ë§¥ë½ì„ ì¡ê³ , 
    í•µì‹¬ êµ¬ê°„(target_text)ì˜ 'ê¸°ë°œí•œ í•´ê²°ì±… ì œì•ˆ'ê¹Œì§€ë§Œ ë³´ì—¬ì£¼ê³  ê·¸ ê²°ê³¼ë¥¼ ìˆ¨ê¸°ëŠ” ì˜ˆê³ í¸ì„ ì‘ì„±í•©ë‹ˆë‹¤.
    """
    
    # 1. ê¸¸ì´ ì˜µì…˜ ì„¤ì •
    if duration_opt == "Short":
        time_range = "30ì´ˆ ~ 50ì´ˆ"; char_limit = "200 ~ 300ì"
    elif duration_opt == "Long":
        time_range = "1ë¶„ 30ì´ˆ ~ 1ë¶„ 50ì´ˆ"; char_limit = "600 ~ 750ì"
    else: # Standard
        time_range = "1ë¶„ ~ 1ë¶„ 20ì´ˆ"; char_limit = "400 ~ 530ì"

    # ìºë¦­í„° ëª©ë¡ ë¬¸ìì—´ ìƒì„± (í”„ë¡¬í”„íŠ¸ ì°¸ê³ ìš©)
    char_list_str = ""
    if char_info and "characters" in char_info:
        for c in char_info["characters"]:
            char_list_str += f"- {c['name']} (ID: {c['id']}, ì„±ë³„: {c['gender']}, ë‚˜ì´: {c['age_group']}, ëª©ì†Œë¦¬ íƒ€ì… : {c['voice_type']})\n"

    system_prompt = f"""
    ë‹¹ì‹ ì€ ê´€ê°ì˜ í˜¸ê¸°ì‹¬ì„ ìê·¹í•˜ë©° ì›ì‘ì˜ ì¶œì²˜ë¥¼ ì •í™•íˆ ë°íˆë©° ë¶„ì„ëœ ìºë¦­í„° í™”ìë¥¼ ë°°ì •í•˜ëŠ” **ì˜í™” ì˜ˆê³ í¸ í¸ì§‘ì**ì…ë‹ˆë‹¤.
    ì œê³µëœ [ì „ì²´ ì›ë¬¸]ì—ëŠ” `--- Page N ---` í˜•ì‹ìœ¼ë¡œ í˜ì´ì§€ ë²ˆí˜¸ê°€ ì í˜€ ìˆìŠµë‹ˆë‹¤.
     **ê¸°ë°œí•œ ì•„ì´ë””ì–´ê°€ ë‚˜ì˜¤ëŠ” ìˆœê°„**ì—ì„œ ë”± ë©ˆì¶”ëŠ” ëŒ€ë³¸ì„ ì‘ì„±í•˜ì„¸ìš”. ë˜í•œ ì˜ˆê³ í¸ ëŒ€ë³¸ì„ ì‘ì„±í•  ë•Œ, **ê° ë¬¸ì¥ì´ ì›ë¬¸ì˜ ëª‡ í˜ì´ì§€(Page N) ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì¼ëŠ”ì§€** ì •í™•íˆ ëª…ì‹œí•˜ì„¸ìš”.

    [ğŸ¯ íƒ€ê²Ÿ ì •ë³´]
    - ëŒ€ìƒ: {age_info['group']}
    - ëª©í‘œ ì‹œê°„: {time_range} (ê¸€ììˆ˜: {char_limit} ë‚´ì™¸)
    - ë§íˆ¬: {age_info['tone']} (ì›ë¬¸ì˜ ì–´íˆ¬ ìœ ì§€)

    [ğŸ‘¥ **í™”ì ë°°ì • ê·œì¹™ (Step 1.5 ë°ì´í„° ë°˜ì˜)**]
    1. **ìºë¦­í„° ëª©ë¡**: ì•„ë˜ ë¶„ì„ëœ ìºë¦­í„°ì˜ **ID**ì„ `speaker` í•„ë“œì— ì‚¬ìš©í•˜ì„¸ìš”.
       {char_list_str}
    2. **ìš°ì„ ìˆœìœ„ (Mixed Sentence)**: í•œ ë¬¸ì¥ì— **ì§€ë¬¸(ë‚˜ë ˆì´ì…˜)ê³¼ ëŒ€ì‚¬("")ê°€ ì„ì—¬ ìˆë‹¤ë©´**, `speaker` í•„ë“œì—ëŠ” ë°˜ë“œì‹œ **ëŒ€ì‚¬ë¥¼ ë§í•˜ëŠ” ìºë¦­í„°ì˜ ID**ë¥¼ ì ìœ¼ì„¸ìš”.
       - (ì˜ˆì‹œ) í…ìŠ¤íŠ¸: 'í˜•ë“¤ì€ "ë¯¸ì•ˆí•´"ë¼ê³  ë§í–ˆì–´ìš”.'
       - (X) speaker: "narrator" (í‹€ë¦¼! ëŒ€ì‚¬ê°€ ìˆìœ¼ë¯€ë¡œ ìºë¦­í„° ìš°ì„ )
       - (O) speaker: "char_01" (ì •ë‹µ! ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ ë”°ì˜´í‘œ ì•ˆë§Œ ìºë¦­í„° ëª©ì†Œë¦¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.)
    3. **Narrator**: ìˆœìˆ˜í•˜ê²Œ ìƒí™© ì„¤ëª…ë§Œ ìˆëŠ” ë¬¸ì¥ì¼ ë•Œë§Œ `narrator`ë¥¼ ì“°ì„¸ìš”.
    4. **ë§¤ì¹­ ì›ì¹™**: ì›ë¬¸ì— ìˆëŠ” ëŒ€ì‚¬ë¥¼ ì¸ìš©í•  ê²½ìš°, í•´ë‹¹ ëŒ€ì‚¬ì˜ ì›ë˜ í™”ìì˜ **ID**ì„ ì •í™•íˆ ì“°ì„¸ìš”.

    [âœï¸ ë¬¸ì¥ ì‘ì„± í•„ìˆ˜ ê·œì¹™ (Syntax Rules) - ë§¤ìš° ì¤‘ìš”]
    1. **ì™„ì „í•œ ë¬¸ì¥ ì‚¬ìš©**: "ì¡°ìš©í•œ ìˆ²ê¸¸..." ê°™ì€ ëª…ì‚¬í˜• ì¢…ê²°ì´ë‚˜ ë§ì¤„ì„í‘œë¡œ ë¬¸ì¥ì„ ëë‚´ì§€ ë§ˆì„¸ìš”.
       - (X) "ìˆ²ì†ì˜ ê³ ìŠ´ë„ì¹˜â€¦ ì¿µ!"
       - (O) "ìˆ²ì†ì— ì‚¬ëŠ” ê³ ìŠ´ë„ì¹˜ëŠ” ê¹œì§ ë†€ëì–´ìš”."
    2. **ìœ¡í•˜ì›ì¹™ í•„ìˆ˜ (Who/What/How)**: ë¬¸ì¥ë§Œ ë³´ê³ ë„ ìƒí™©ì´ ì´í•´ë˜ë„ë¡ ì£¼ì–´ì™€ ëª©ì ì–´ë¥¼ ëª…í™•íˆ í•˜ì„¸ìš”. "ê·¸ê²ƒì„ ë³´ì•˜ì–´ìš”" ëŒ€ì‹  "ì² ìˆ˜ëŠ” í”¼ ë¬»ì€ ì¹¼ì„ ë³´ì•˜ìŠµë‹ˆë‹¤"ì²˜ëŸ¼ **ëˆ„ê°€, ë¬´ì—‡ì„, ì–´ë–»ê²Œ í–ˆëŠ”ì§€** êµ¬ì²´ì ìœ¼ë¡œ ì„œìˆ í•´ì•¼ í•©ë‹ˆë‹¤.
    3. **ì„œìˆ ì–´ í•„ìˆ˜**: ëª¨ë“  ë¬¸ì¥ì€ ì£¼ì–´ì™€ ì„œìˆ ì–´(~ë‹¤, ~ìš”)ë¥¼ ê°–ì¶°ì•¼ í•©ë‹ˆë‹¤.
    4. **ì˜ì„±ì–´/ì˜íƒœì–´ í†µí•©**: ì˜ì„±ì–´ë§Œ ë‹¨ë…ìœ¼ë¡œ ì“°ì§€ ë§ê³ , ë¬¸ì¥ ì•ˆì— ìì—°ìŠ¤ëŸ½ê²Œ ë…¹ì—¬ë‚´ì„¸ìš”.
       - (X) "ì™€ë¥´ë¥´!"
       - (O) "ë„í† ë¦¬ê°€ 'ì™€ë¥´ë¥´' ìŸì•„ì ¸ ë‚´ë ¸ì§€ìš”!"
    5. **ì ‘ì†ì‚¬ í™œìš©**: ë¬¸ì¥ê³¼ ë¬¸ì¥ ì‚¬ì´ê°€ ëšëš ëŠê¸°ì§€ ì•Šë„ë¡ 'ê·¸ëŸ°ë°', 'ë°”ë¡œ ê·¸ë•Œ', 'í•˜ì§€ë§Œ' ë“±ìœ¼ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ì´ìœ¼ì„¸ìš”.

    [â›” í¸ì§‘ì˜ í•µì‹¬ ê·œì¹™ (ì ˆë‹¨ì‹ ê³µ)]
    1. **'ì œì•ˆ'ì€ ë…¸ì¶œ, 'ê²°ê³¼'ëŠ” ì‚­ì œ (ë§¤ìš° ì¤‘ìš”)**: 
       - í•µì‹¬ êµ¬ê°„ì— ë“±ì¥í•˜ëŠ” **ê¸°ìƒì²œì™¸í•œ í•´ê²°ì±…ì´ë‚˜ ì•„ì´ë””ì–´**(ì˜ˆ: "ë„í† ë¦¬ë¡œ ì˜·ì„ ë§Œë“¤ì!")ëŠ” ì˜ˆê³ í¸ì˜ í•˜ì´ë¼ì´íŠ¸ì…ë‹ˆë‹¤. **ë°˜ë“œì‹œ í¬í•¨í•˜ì„¸ìš”.**
       - í•˜ì§€ë§Œ, ê·¸ ì•„ì´ë””ì–´ë¥¼ **ì‹¤í–‰í•˜ëŠ” ê³¼ì •(ë§Œë“œëŠ” ì¥ë©´)ì´ë‚˜ ì„±ê³µí•œ ê²°ê³¼**ëŠ” ì ˆëŒ€ ë³´ì—¬ì£¼ì§€ ë§ˆì„¸ìš”.
    2. **íƒ€ì´ë°**: ëˆ„êµ°ê°€ "ì¢‹ì€ ìƒê°ì´ ë‚¬ì–´! ~ë¥¼ í•´ë³´ì!"ë¼ê³  ì™¸ì¹˜ëŠ” ìˆœê°„ì´ ì—”ë”© ì§ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    3. **íŒ©íŠ¸ ì¤€ìˆ˜**: ì›ë¬¸ì— ì—†ëŠ” ë‚´ìš©ì€ ì§€ì–´ë‚´ì§€ ë§ˆì„¸ìš”.

    [âœï¸ ì‘ì„± ê°€ì´ë“œ (ì„œì‚¬ êµ¬ì„±)]
    1. **ë„ì… (Intro)**: [ì „ì²´ ì›ë¬¸]ì„ í™œìš©í•´ ì£¼ì¸ê³µì˜ í‰í™”ë¡œìš´ ì¼ìƒì´ë‚˜ ì‚¬ê±´ì˜ ë°œë‹¨ì„ ì†Œê°œí•˜ì„¸ìš”.
    2. **ìœ„ê¸° (Crisis)**: ì£¼ì¸ê³µì´ ê³¤ë€í•œ ìƒí™©ì— ë¹ ì ¸ "ì–´ë–¡í•˜ì§€?"ë¼ê³  ê³ ë¯¼í•˜ëŠ” ê³¼ì •ì„ [í•µì‹¬ êµ¬ê°„]ì—ì„œ ê°€ì ¸ì˜¤ì„¸ìš”.
    3. **ë°˜ì „ (The Hook)**: [í•µì‹¬ êµ¬ê°„]ì— ìˆëŠ” **í•´ê²°ì±… ì œì•ˆ ëŒ€ì‚¬**("ë„í† ë¦¬ ì˜·ì„ ë§Œë“¤ì!")ë¥¼ í´ë¼ì´ë§‰ìŠ¤ë¡œ ë°°ì¹˜í•˜ì„¸ìš”.
    4. **ë§ˆë¬´ë¦¬ (Outro)**: ì œì•ˆì´ ë‚˜ì˜¤ìë§ˆì ë°”ë¡œ ë‚´ë ˆì´ì…˜ìœ¼ë¡œ ë„˜ê¸°ì„¸ìš”. 
       - "ê³¼ì—° ì´ ì—‰ëš±í•œ ë°©ë²•ì´ í†µí• ê¹Œìš”?", "ë„í† ë¦¬ ì˜·ì´ë¼ë‹ˆ, ì •ë§ ê°€ëŠ¥í• ê¹Œìš”?"

    [âœï¸ ì‘ì„± ê°€ì´ë“œ (ì¶œì²˜ ì¶”ì  Source Page)]
       - ëŒ€ë³¸ì˜ í•œ ì¤„ì„ ì“¸ ë•Œë§ˆë‹¤, ê·¸ ë‚´ìš©ì´ ìˆëŠ” **í˜ì´ì§€ ë²ˆí˜¸(ìˆ«ìë§Œ)**ë¥¼ ì°¾ìœ¼ì„¸ìš”.
       - ì—¬ëŸ¬ í˜ì´ì§€ì— ê±¸ì¹œ ë‚´ìš©ì´ë¼ë©´, ê°€ì¥ í•µì‹¬ì´ ë˜ëŠ” í˜ì´ì§€ í•˜ë‚˜ë¥¼ ê³ ë¥´ì„¸ìš”.
       - ì›ë¬¸ì— ì—†ëŠ” ë‚´ë ˆì´ì…˜(ì§ˆë¬¸ ë“±)ì€ ì§ì „ ì¥ë©´ì˜ í˜ì´ì§€ë¥¼ ë”°ë¥´ê±°ë‚˜, í‘œì§€(5í˜ì´ì§€)ë¡œ ì„¤ì •í•˜ì„¸ìš”.
       - ë‹¨, **ì˜ˆê³ í¸ì˜ ë§ˆì§€ë§‰ ì”¬ì´ ê´€ê°ì—ê²Œ ë˜ì§€ëŠ” ë‚´ë ˆì´ì…˜ ì§ˆë¬¸(ê¶ê¸ˆì¦ ìœ ë°œ)ìœ¼ë¡œ ëë‚˜ëŠ” ê²½ìš°**, ê·¸ ë§ˆì§€ë§‰ ìë§‰ì˜ `source_page`ëŠ” **0**ìœ¼ë¡œ ì„¤ì •í•´ë„ ë©ë‹ˆë‹¤.
        - ì´ ê·œì¹™ì€ **ë§ˆì§€ë§‰ ì”¬ 1ê°œì—ë§Œ ì ìš©**ë©ë‹ˆë‹¤.
       
    [ğŸš« **í¼ì¹¨ë©´(Spread) ì¤‘ë³µ ë°©ì§€ ê·œì¹™ (ë§¤ìš° ì¤‘ìš”)**]
    1. **ë‹¤ì–‘í•œ ì¥ë©´ ì‚¬ìš©**: í•œ ì¥ì†Œ(í¼ì¹¨ë©´)ì—ì„œ ë„ˆë¬´ ë§ì€ ëŒ€ì‚¬ê°€ ë‚˜ì˜¤ë©´ ì˜ìƒì´ ì§€ë£¨í•´ì§‘ë‹ˆë‹¤.
    2. **í¼ì¹¨ë©´ ì •ì˜**: [ì§ìˆ˜ í˜ì´ì§€(2k)]ì™€ [í™€ìˆ˜ í˜ì´ì§€(2k+1)]ì€ í•˜ë‚˜ì˜ í¼ì¹¨ë©´(ê°™ì€ ê·¸ë¦¼)ì…ë‹ˆë‹¤. (ì˜ˆ: 20pì™€ 21pëŠ” ê°™ì€ ì¥ë©´)
    3. **ìµœëŒ€ í—ˆìš© í•œë„**: **í•˜ë‚˜ì˜ í¼ì¹¨ë©´ì—ì„œ ëŒ€ì‚¬ë¥¼ 2ê°œê¹Œì§€ë§Œ ê°€ì ¸ì˜¤ì„¸ìš”.** (3ê°œ ì´ìƒ ì—°ì† ê¸ˆì§€)
       - (X) Scene 1(20p), Scene 2(21p), Scene 3(20p) -> **ì§€ë£¨í•¨!**
       - (O) Scene 1(20p), Scene 2(21p) -> Scene 3(ë‹¤ìŒ ì¥ìœ¼ë¡œ ì´ë™)
    4. ë§Œì•½ ëŒ€í™”ê°€ ê¸¸ì–´ì§„ë‹¤ë©´, ê³¼ê°íˆ ìš”ì•½í•˜ê±°ë‚˜ ë‚´ë ˆì´ì…˜ìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¥ë©´ì„ ë„˜ê¸°ì„¸ìš”.
          
    [ğŸ—£ï¸ í™”ì ë°°ì •]
    - **narrator**: ìƒí™© ì„¤ëª…, ë§ˆì§€ë§‰ ì§ˆë¬¸ ë˜ì§€ê¸°.
    - **ìºë¦­í„°**: ì›ë¬¸ì˜ ë”°ì˜´í‘œ("") ì•ˆ **ì§ì ‘ ëŒ€ì‚¬**ë§Œ ì‚¬ìš©. (ì•„ì´ë””ì–´ë¥¼ ì œì•ˆí•˜ëŠ” ìºë¦­í„°ì˜ ëŒ€ì‚¬ëŠ” í•„ìˆ˜ í¬í•¨!)
    
    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "subtitles": [
            {{"text": "ì˜›ë‚  ì–´ëŠ ìˆ²ì†ì—, ìš•ì‹¬ìŸì´ í˜¸ë‘ì´ê°€ ì‚´ê³  ìˆì—ˆì–´ìš”.", "speaker": "narrator","source_page": 2}},
            {{"text": "ì–´í¥! ë§›ìˆëŠ” ë–¡ í•˜ë‚˜ ì£¼ë©´ ì•ˆ ì¡ì•„ë¨¹ì§€!", "speaker": "char_03","source_page": 6}},
            {{"text": "í˜¸ë‘ì´ëŠ” ì˜¤ëˆ„ì´ë¥¼ í–¥í•´ ë¬´ì„­ê²Œ ë‹¬ë ¤ë“¤ì—ˆë‹µë‹ˆë‹¤.", "speaker": "narrator","source_page": 11}},
            {{"text": "ê³¼ì—° ì˜¤ëˆ„ì´ëŠ” í˜¸ë‘ì´ë¥¼ í”¼í•´ ë„ë§ì¹  ìˆ˜ ìˆì„ê¹Œìš”?", "speaker": "narrator","source_page": 15}},
             {{"text": "í•˜ì§€ë§Œ í˜•ë“¤ì€ "ë¯¸ì•ˆí•´. ìš°ë¦¬ê°€ ë‹¤ì‹œ ê·¸ë ¤ ì¤„ê²Œ." í•˜ê³  ì¡°ì‹¬ì¡°ì‹¬ ë§í–ˆì–´ìš”.", "speaker": "char_04","source_page": 17}},
            {{"text": "ì–´ë–»ê²Œìš”? í• ë¨¸ë‹ˆê°€ í•œë²ˆ ë³´ì—¬ ì£¼ì„¸ìš”?", "speaker": "char_01","source_page": 27}},
            {{"text": "í—¨ì ¤, ì†ê°€ë½ì„ ë‚´ë°€ì–´ ë´ë¼. ì–¼ë§ˆë‚˜ ì‚´ì´ ìª˜ëŠ”ì§€ ë³´ì.", "speaker": "char_02","source_page": 24}},
            {{"text": "í˜•ë‹˜, ìŒ€ ì¡°ê¸ˆë§Œ ê¾¸ì–´ì£¼ì„¸ìš”.", "speaker": "char_01", "source_page": 8}}
        ],
        "estimated_duration": "ì˜ˆìƒ ì‹œê°„",
        "comment": "ì›ë¬¸ì˜ ì–´ëŠ ë¬¸ì¥ì„ í™œìš©í–ˆëŠ”ì§€ ê°„ëµ ì„¤ëª…"
    }}
    """
    
    # ì›ë¬¸ ì „ì²´ë¥¼ ì°¸ê³  ìë£Œë¡œ ì œê³µ
    user_content = f"""
    [ì°¸ê³  ìë£Œ 1: ì „ì²´ ì›ë¬¸ í…ìŠ¤íŠ¸ (Context & Facts)]
    {full_text}

    [ì°¸ê³  ìë£Œ 2: ì˜ˆê³ í¸ì˜ í•µì‹¬ í•˜ì´ë¼ì´íŠ¸ êµ¬ê°„ (Focus)]
    {target_text}
    """

    response = client.chat.completions.create(
        model="gpt-5.2", # ê¸´ í…ìŠ¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•´ gpt-5.2 ê¶Œì¥
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_content}
        ],
        response_format={"type": "json_object"}
    )
    
    return json.loads(response.choices[0].message.content)


# --------------------------------
# [Step 3 Helper] ëŒ€í™”ë¬¸ ìœ„ì£¼(Conversation)ì—ì„œ ëŒ€í™”ë¬¸ì—ì„œì˜ ì˜ì„±ì–´/íš¨ê³¼ìŒ ì œê±° í•¨ìˆ˜
# --------------------------------
def has_real_sentence_after_sfx(q: str) -> bool:
    # "ì§¹ì§¹, ì €ëŠ” ..." / "ì¿µ! ë¬´ìŠ¨ ì†Œë¦¬ì•¼?" ê°™ì€ ì¼€ì´ìŠ¤ë¥¼ ì‚´ë¦¼
    # êµ¬ë‘ì  ë’¤ì— í•œê¸€/ì˜ë¬¸/ìˆ«ì ê°™ì€ ë³¸ë¬¸ì´ ì´ì–´ì§€ë©´ True
    return re.search(r"[,\.\!\?\â€¦]\s*[ê°€-í£A-Za-z0-9]", q) is not None

def is_sfx_like(quote: str) -> bool:
    """
    ì˜ì„±ì–´/íš¨ê³¼ìŒ/ë™ë¬¼ ìš¸ìŒ ê°™ì€ 'ëŒ€ì‚¬ ì•„ë‹Œ' ì§§ì€ ë¬¸ìì—´ì„ ê±¸ëŸ¬ë‚´ê¸° ìœ„í•œ íœ´ë¦¬ìŠ¤í‹±.
    ì™„ë²½í•˜ì§„ ì•Šì§€ë§Œ ì‹¤ë¬´ì—ì„œ ê½¤ ì˜ ê±¸ëŸ¬ì§.
    """
    if not quote:
        return True

    q = quote.strip()
    # (ì˜ˆì™¸) íš¨ê³¼ìŒì´ ì•ì— ë¶™ì—ˆì§€ë§Œ ë’¤ì— ë¬¸ì¥ì´ ì´ì–´ì§€ë©´ ëŒ€ì‚¬ë¡œ ì·¨ê¸‰
    if has_real_sentence_after_sfx(q):
        return False

    # 1) ë„ˆë¬´ ì§§ì€ ë‹¨ë… ì†Œë¦¬(ì˜ˆ: "í†¡", "ì§¹ì§¹", "ì¿µ")
    #    (í•œê¸€ 1~6ì + ì„ íƒì  ë°˜ë³µ/êµ¬ë‘ì  ì •ë„)
    if len(q) <= 6:
        # í•œê¸€/ìëª¨/ë°˜ë³µê¸°í˜¸/ëŠë‚Œí‘œ/ë¬¼ìŒí‘œ/ì‰¼í‘œë§Œìœ¼ë¡œ êµ¬ì„±ë˜ë©´ íš¨ê³¼ìŒìœ¼ë¡œ ê°„ì£¼
        if re.fullmatch(r"[ê°€-í£ã„±-ã…ã…-ã…£,!.?~â€¦Â·\-]+", q):
            return True

    # 2) 'ì˜ì„±ì–´ íŒ¨í„´'ì´ ì—°ì†ë˜ëŠ” ê²½ìš° (ì˜ˆ: "ìš°ë¥´ë¦‰ ì¿µì¿µì¿µ", "ì§¹ì§¹, íŒŒë“œë‹¥!")
    #    ë‹¨ì–´ê°€ 2ê°œ ì´ìƒì´ê³ , ê° ë‹¨ì–´ê°€ ì§§ê³ (<=6) ì˜ë¯¸ ìˆëŠ” ë¬¸ì¥ ë¶€í˜¸/ì¡°ì‚¬ê°€ ê±°ì˜ ì—†ìœ¼ë©´ sfxë¡œ ê°„ì£¼
    tokens = re.split(r"[\s,]+", q)
    tokens = [t for t in tokens if t]
    if len(tokens) >= 2:
        short_koreanish = 0
        for t in tokens:
            t2 = re.sub(r"[!.?~â€¦Â·\-]", "", t)
            if 1 <= len(t2) <= 6 and re.fullmatch(r"[ê°€-í£ã„±-ã…ã…-ã…£]+", t2):
                short_koreanish += 1
        if short_koreanish == len(tokens):
            return True

    # 3) ëª…ë°±í•œ SFX í‘œê¸° (ê´„í˜¸/ëŒ€ê´„í˜¸ ì•ˆì— ì†Œë¦¬)
    #    ì˜ˆ: "(ì¿µ!)", "[íš¨ê³¼ìŒ] ìš°ë¥´ë¦‰"
    if re.match(r"^[\(\[\{].*[\)\]\}]$", q):
        return True
    if re.search(r"(íš¨ê³¼ìŒ|ì˜ì„±ì–´|ì˜íƒœì–´|sound|sfx)", q, re.IGNORECASE):
        return True

    # 4) ë¬¸ì¥ìœ¼ë¡œ ë³´ê¸° ì–´ë ¤ìš´ ê²½ìš°(ë¬¸ì¥ë¶€í˜¸/ì¡°ì‚¬/ë„ì–´ì“°ê¸° ì¡°í•©ì´ ê±°ì˜ ì—†ê³  ë°˜ë³µë§Œ ë§ìŒ)
    #    ì˜ˆ: "ì¿µì¿µì¿µì¿µ", "ìš°ë¥´ë¥´ë¥´ë¥´"
    if re.fullmatch(r"[ê°€-í£ã„±-ã…ã…-ã…£]+", q) and re.search(r"(.)\1\1", q):
        # ê°™ì€ ë¬¸ìê°€ 3ë²ˆ ì´ìƒ ë°˜ë³µë˜ëŠ” íŒ¨í„´ì´ ìˆìœ¼ë©´ íš¨ê³¼ìŒ ê°€ëŠ¥ì„± ë†’ìŒ
        return True

    return False

# --------------------------------
# [Step 3 Helper] ëŒ€í™”ë¬¸ ìœ„ì£¼(Conversation) ëŒ€ë³¸ ì‘ì„± í•¨ìˆ˜ 
# --------------------------------
def generate_conversation_oriented_script(target_text: str, duration_opt: str, age_info: dict, full_text: str, char_info: dict):
    """
    [Step 1.5 ë°ì´í„° ê¸°ë°˜ Selector]
    GPTê°€ ë¬¸ì¥ì„ ìƒˆë¡œ ì“°ì§€ ì•Šê³ , Step 1.5ì—ì„œ ì´ë¯¸ ë¶„ì„ëœ `dialogue_map` ë¦¬ìŠ¤íŠ¸ì—ì„œ
    ì˜ˆê³ í¸ì— ì‚¬ìš©í•  ëŒ€ì‚¬ì˜ 'ì¸ë±ìŠ¤(Index)'ë¥¼ ì„ íƒí•˜ì—¬ ì¡°ë¦½í•©ë‹ˆë‹¤.
    
    Returns:
        Step 3ì™€ ë™ì¼í•œ JSON êµ¬ì¡° (subtitles, text, speaker, source_page)
    """
    
    # 1. í•„ìˆ˜ ë°ì´í„° ê²€ì¦
    if not char_info or "dialogue_map" not in char_info or not char_info["dialogue_map"]:
        # ë°ì´í„°ê°€ ì—†ì„ ê²½ìš° ì˜ˆì™¸ ì²˜ë¦¬ë³´ë‹¤ëŠ” ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜ í˜¹ì€ ì—ëŸ¬ ë¡œê¹…
        return {"subtitles": [], "estimated_duration": duration_opt, "comment": "Step 1.5 ë°ì´í„° ì—†ìŒ"}

    spoiler_limit_page = None
    dialogue_list = char_info["dialogue_map"]
    characters = char_info.get("characters", [])
    # 1) íš¨ê³¼ìŒ/ì˜ì„±ì–´ í›„ë³´ ì œê±°
    raw_dialogue_list = char_info["dialogue_map"]
    dialogue_list = [d for d in raw_dialogue_list if not is_sfx_like(d.get("quote", ""))]
    # page_numì´ ë§ë„ ì•ˆ ë˜ê²Œ í° ê²Œ ì„ì—¬ ë“¤ì–´ì˜¤ëŠ” ìƒí™© ì°¨ë‹¨
    dialogue_list = [d for d in dialogue_list if int(d.get("page_num", 0)) > 0]

    # í™”ì ID -> ëª©ì†Œë¦¬ íƒ€ì… ë§¤í•‘ ìƒì„±
    speaker_meta = {}
    for c in characters:
        # voice_typeì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ narrator
        speaker_meta[c['id']] = c.get("id", "narrator") 
        # ì°¸ê³ : ì´ë¦„ì„ ë§¤í•‘í•˜ê³  ì‹¶ë‹¤ë©´ c['name'] ì‚¬ìš© ê°€ëŠ¥

    # 2. GPTì—ê²Œ ë„˜ê²¨ì¤„ ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ í…ìŠ¤íŠ¸í™”
    # í¬ë§·: [Index] í™”ìID: ëŒ€ì‚¬ë‚´ìš© (Page N) - ìƒí™©ì„¤ëª…
    dialogue_context_str = ""
    for idx, item in enumerate(dialogue_list):
        s_id = item.get('speaker_id', 'unknown')
        # ë§¤í•‘ëœ ë³´ì´ìŠ¤ íƒ€ì…ì´ë‚˜ ì´ë¦„ ë“±ì„ í‘œì‹œí•´ ì¤Œ (GPTê°€ ë§¥ë½ íŒŒì•…í•˜ê¸° ì¢‹ê²Œ)
        s_role = speaker_meta.get(s_id, "unknown")
        
        dialogue_context_str += f"[{idx}] {s_id}({s_role}): \"{item['quote']}\" (Page {item['page_num']}) | ìƒí™©: {item['context']}\n"

    # 3. ê¸¸ì´ ì˜µì…˜ ì„¤ì •
    if duration_opt == "Short":
        select_guideline = "8ê°œ ~ 12ê°œì˜ ëŒ€ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”."
    elif duration_opt == "Long":
        select_guideline = "18ê°œ ~ 24ê°œì˜ ëŒ€ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”."
    else: # Standard
        select_guideline = "12ê°œ ~ 16ê°œì˜ ëŒ€ì‚¬ë¥¼ ì„ íƒí•˜ì„¸ìš”."

    # =========================================================
    # [System Prompt] í¸ì§‘ì(Editor) ëª¨ë“œ
    # =========================================================
    system_prompt = f"""
    ë‹¹ì‹ ì€ ë™í™”ì±… ì˜ˆê³ í¸ í¸ì§‘ìì…ë‹ˆë‹¤. ë‹¹ì‹ ì—ê²ŒëŠ” ì´ë¯¸ ë¶„ì„ëœ [ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸]ê°€ ìˆìŠµë‹ˆë‹¤.
    ì œê³µëœ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì˜ˆê³ í¸ì˜ ê¸°ìŠ¹ì „ê²°(íŠ¹íˆ ìœ„ê¸°ë‚˜ ê¸°ë°œí•œ ì œì•ˆ ë‹¨ê³„ê¹Œì§€)ì„ ê°€ì¥ ì˜ ë³´ì—¬ì£¼ëŠ” **ëŒ€ì‚¬ë“¤ì˜ ë²ˆí˜¸(Index)**ë¥¼ ìˆœì„œëŒ€ë¡œ ì„ íƒí•˜ì„¸ìš”.

    [ì‘ì—… ëª©í‘œ]
    1. **ì„œì‚¬ êµ¬ì„±**: ì‚¬ê±´ì˜ ë°œë‹¨ -> ê°ˆë“± ì‹¬í™” -> í•´ê²°ì±… ì œì•ˆ/ì ˆì • ì§ì „(ì ˆë‹¨ì‹ ê³µ).
    2. **í‹°í‚¤íƒ€ì¹´**: ëŒ€í™”ê°€ ìì—°ìŠ¤ëŸ½ê²Œ ì´ì–´ì§€ë„ë¡ ì—°ì†ëœ ì¸ë±ìŠ¤ë¥¼ ë¬¶ì–´ì„œ ì„ íƒí•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.

    [ì œê³µëœ ë°ì´í„°]
    - í•µì‹¬ ìš”ì•½(Target): {target_text}

    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "selected_indices": [
            {{ "index": 0, "reason": "ë„ì…ë¶€" }},
            {{ "index": 1, "reason": "ì´ì–´ì§€ëŠ” ëŒ€í™”" }},
            {{ "index": 5, "reason": "ì í”„í•˜ì—¬ ìœ„ê¸° ìƒí™©" }}
        ],
        "comment": "ì „ë°˜ì ì¸ í¸ì§‘ ì˜ë„"
    }}

    [ì œì•½ ì‚¬í•­]
    - ë°˜ë“œì‹œ ì œê³µëœ ë¦¬ìŠ¤íŠ¸ì˜ **[ìˆ«ì] Index**ë§Œ ì‚¬ìš©í•˜ì„¸ìš”.
    - "ìš°ë¥´ë¦‰", "ì¿µì¿µ", "í†¡í†¡", "ì§¹ì§¹" ê°™ì€ **íš¨ê³¼ìŒ/ì˜ì„±ì–´/ë™ë¬¼ ìš¸ìŒ**ìœ¼ë¡œ ë³´ì´ëŠ” ëŒ€ì‚¬ëŠ” ì„ íƒí•˜ì§€ ë§ˆì„¸ìš”.
    - {select_guideline}
    """
    
    user_content = f"""
    [ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ (Candidate Dialogues)]
    {dialogue_context_str}
    """

    try:
        response = client.chat.completions.create(
            model="gpt-5.2",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_content}
            ],
            response_format={"type": "json_object"},
            temperature=0.1 # ì¸ë±ìŠ¤ ì„ íƒì˜ ì •í™•ì„±ì„ ìœ„í•´ ë‚®ì¶¤
        )
        
        gpt_result = json.loads(response.choices[0].message.content)
        
        # 5. [Post-Processing] ì„ íƒëœ ì¸ë±ìŠ¤ë¥¼ Step 3ì™€ ë™ì¼í•œ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        final_subtitles = []
        selected_indices = gpt_result.get("selected_indices", [])
        
        for item in selected_indices:
            idx = item["index"]
            
            # ì¸ë±ìŠ¤ ìœ íš¨ì„± ê²€ì‚¬
            if 0 <= idx < len(dialogue_list):
                original_data = dialogue_list[idx]
                speaker_id = original_data.get("speaker_id")
                
                # Step 1.5 ë°ì´í„° ë§¤í•‘
                # Step 3(generate_script_with_specs)ì˜ ë°˜í™˜ í¬ë§·(text, speaker, source_page)ì„ ì—„ê²©íˆ ì¤€ìˆ˜
                scene_obj = {
                    "text": original_data["quote"],        # â˜… Step 1.5ì˜ ì›ë¬¸ ëŒ€ì‚¬ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ë§¤ì¹­ í‚¤)
                    "speaker": speaker_meta.get(speaker_id, "narrator"), # Voice Type
                    "source_page": original_data["page_num"],
                    # í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì— contextë¥¼ ë¯¸ë¦¬ í¬í•¨í•  ìˆ˜ë„ ìˆì§€ë§Œ, 
                    # ìš”ì²­í•˜ì‹  ëŒ€ë¡œ 'Step 3 ë°˜í™˜ ì–‘ì‹'ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ìµœì†Œí™”í•˜ê±°ë‚˜,
                    # ë‚˜ì¤‘ì— í¸ì˜ë¥¼ ìœ„í•´ hidden fieldë¡œ contextë¥¼ ë„£ì–´ë‘˜ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
                    # ì—¬ê¸°ì„œëŠ” Step 8ì—ì„œ quoteë¡œ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ì›ë³¸ í…ìŠ¤íŠ¸ ìœ ì§€ì— ì§‘ì¤‘í•©ë‹ˆë‹¤.
                }
                final_subtitles.append(scene_obj)
        
        # ê²°ê³¼ ë°˜í™˜ (Step 3ì™€ ë™ì¼í•œ í‚¤ êµ¬ì¡°)
        return {
            "subtitles": final_subtitles,
            "estimated_duration": duration_opt,
            "comment": gpt_result.get("comment", "")
        }

    except Exception as e:
        return {
            "subtitles": [],
            "estimated_duration": duration_opt,
            "comment": f"Error in Step 3: {str(e)}"
        }


# --------------------------------
# [Step 3 Helper] ì¢…í•©(Comprehensive) êµ¬ì„± (4-Step Trailer Formula Edition) ëŒ€ë³¸ ì‘ì„± í•¨ìˆ˜
# --------------------------------
def generate_comprehensive_script(target_text: str, duration_opt: str, age_info: dict, full_text: str, char_info: dict, analysis_data: dict):
    """
    ì „ì²´ ì›ë¬¸(full_text)ê³¼ í•µì‹¬ êµ¬ê°„(target_text)ì„ í™œìš©í•˜ì—¬
    [í›… - ì´ˆì••ì¶• - ë¹Œë“œì—… - ì ˆë‹¨]ì˜ 4ë‹¨ê³„ ê³µì‹ì„ ë”°ë¥´ëŠ” ì˜ˆê³ í¸ ëŒ€ë³¸ì„ ì‘ì„±í•©ë‹ˆë‹¤.
    """
    
    # 1. ê¸¸ì´ ì˜µì…˜ ì„¤ì •
    if duration_opt == "Short":
        time_range = "30ì´ˆ ~ 50ì´ˆ"; char_limit = "200 ~ 300ì"
    elif duration_opt == "Long":
        time_range = "1ë¶„ 30ì´ˆ ~ 1ë¶„ 50ì´ˆ"; char_limit = "600 ~ 750ì"
    else: # Standard
        time_range = "1ë¶„ ~ 1ë¶„ 20ì´ˆ"; char_limit = "400 ~ 530ì"

    # ìºë¦­í„° ëª©ë¡ ë¬¸ìì—´ ìƒì„±
    char_list_str = ""
    if char_info and "characters" in char_info:
        for c in char_info["characters"]:
            char_list_str += f"- {c['name']} (ID: {c['id']}, ì„±ë³„: {c['gender']}, ë‚˜ì´: {c['age_group']}, ëª©ì†Œë¦¬ íƒ€ì… : {c['voice_type']})\n"

    system_prompt = f"""
    ë‹¹ì‹ ì€ ê´€ê°ì˜ ë„íŒŒë¯¼ì„ ìê·¹í•˜ëŠ” **ìˆí¼/ì˜í™” ì˜ˆê³ í¸ ì „ë¬¸ í¸ì§‘ì**ì…ë‹ˆë‹¤.
    ì œê³µëœ [ì „ì²´ ì›ë¬¸]ê³¼ [í•µì‹¬ êµ¬ê°„]ì„ ë°”íƒ•ìœ¼ë¡œ **'4ë‹¨ê³„ ì‹¤ì „ ì••ì¶• ê³µì‹'**ì„ ì™„ë²½í•˜ê²Œ ì ìš©í•œ ëŒ€ë³¸ì„ ì‘ì„±í•˜ì„¸ìš”.
    ê° ë¬¸ì¥ì´ ì›ë¬¸ì˜ ëª‡ í˜ì´ì§€(Page N) ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì¼ëŠ”ì§€ `source_page`ì— ì •í™•íˆ ëª…ì‹œí•˜ì„¸ìš”.

    [ íƒ€ê²Ÿ ì •ë³´]
    - ëŒ€ìƒ: {age_info['group']}
    - ëª©í‘œ ì‹œê°„: {time_range} (ê¸€ììˆ˜: {char_limit} ë‚´ì™¸)
    - ë§íˆ¬: {age_info['tone']} (ì›ë¬¸ì˜ ì–´íˆ¬ ìœ ì§€)

    [ **4ë‹¨ê³„ ì‹¤ì „ ì••ì¶• ê³µì‹ (Strict Formula)**]
    ì•„ë˜ ìˆœì„œë¥¼ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš”. ì‹œê°„ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•˜ì§€ ë§ê³ , **ê°€ì¥ ê°•ë ¬í•œ ì¥ë©´ì„ ë¨¼ì € ë°°ì¹˜**í•˜ëŠ” í¸ì§‘ ê¸°ìˆ ì„ ì“°ì„¸ìš”.

    **1ë‹¨ê³„: í›… (Hook) - "ê°€ì¥ ì„¼ í•œ ë§ˆë””"**
    - **ëª©í‘œ:** ì˜ìƒ ì‹œì‘ 1ì´ˆ ë§Œì— ì‹œì²­ìì˜ ê·€ë¥¼ ì‚¬ë¡œì¡ê¸°.
    - **ë°©ë²•:** [í•µì‹¬ êµ¬ê°„] í˜¹ì€ ì´ì•¼ê¸° í›„ë°˜ë¶€ì˜ **ê°€ì¥ ìê·¹ì ì´ê³  ê²°ì •ì ì¸ ëŒ€ì‚¬ë‚˜ ìƒí™©**ì„ ë§¨ ì•ìœ¼ë¡œ ê°€ì ¸ì˜¤ì„¸ìš”.
    - **ì£¼ì˜:** ê²°ë§ì„ ë³´ì—¬ì£¼ëŠ” ê²Œ ì•„ë‹ˆë¼, ê¶ê¸ˆì¦ì„ ìœ ë°œí•˜ëŠ” ì¶©ê²©ì ì¸ ëŒ€ì‚¬ì—¬ì•¼ í•©ë‹ˆë‹¤.
    - (ì˜ˆì‹œ) "ê³µì–‘ë¯¸ ì‚¼ë°± ì„ì— ì €ë¥¼ ì¸ë‹¹ìˆ˜ì— ë˜ì ¸ì£¼ì„¸ìš”."

    **2ë‹¨ê³„: ì´ˆì••ì¶• ì „ê°œ (Fast-Forward) - "ì™œ ê·¸ë¬ì–´?"**
    - **ëª©í‘œ:** 1ë‹¨ê³„ì˜ ì¶©ê²©ì ì¸ ìƒí™©ì´ ì˜¤ê²Œ ëœ ë°°ê²½ì„ ì†ë„ê° ìˆê²Œ ìš”ì•½.
    - **ë°©ë²•:** [ì „ì²´ ì›ë¬¸]ì˜ ì•ë¶€ë¶„(ë°œë‹¨)ì„ í™œìš©í•˜ë˜, êµ¬êµ¬ì ˆì ˆí•œ ì„¤ëª…ì€ ìƒëµí•©ë‹ˆë‹¤. ì£¼ì¸ê³µì˜ ë¶ˆí–‰ì´ë‚˜ ì‚¬ê±´ì˜ ì‹œì‘ì„ '~í–ˆê³ , ~í–ˆë‹¤' ì‹ìœ¼ë¡œ ë¹ ë¥´ê²Œ ë‚˜ì—´í•˜ì„¸ìš”.
    - (ì˜ˆì‹œ) "ì•„ë²„ì§€ë¥¼ ìœ„í•´ ì‚¯ë°”ëŠì§ˆë„ í•˜ê³  ë™ëƒ¥ë„ ë‹¤ë…”ì§€ë§Œ, ë°©ë²•ì€ ê³µì–‘ë¿ì´ì—ˆë‹¤. íš¨ë…€ ì‹¬ì²­ì—ê²Œ ë‚¨ì€ ì„ íƒì§€ëŠ” ì—†ì—ˆë‹¤."

    **3ë‹¨ê³„: ì„œì‚¬ ì§‘ì¤‘ (Build-up) - "ì¡°ì—¬ì˜¤ëŠ” ê¸´ì¥"**
    - **ëª©í‘œ:** í´ë¼ì´ë§¥ìŠ¤ ì§ì „ê¹Œì§€ ë¶„ìœ„ê¸° ê³ ì¡°.
    - **ë°©ë²•:** [í•µì‹¬ êµ¬ê°„]ì˜ ë‚´ìš©ì„ ì‚¬ìš©í•˜ì—¬ ìœ„ê¸° ìƒí™©, ìœ„í˜‘, í˜¹ì€ ëŒì´í‚¬ ìˆ˜ ì—†ëŠ” ì„ íƒì˜ ê³¼ì •ì„ ë””í…Œì¼í•˜ê²Œ ë¬˜ì‚¬í•˜ì„¸ìš”. ë°°ê²½ìŒì•…ì´ ê³ ì¡°ë˜ëŠ” ëŠë‚Œìœ¼ë¡œ ê¸´ë°•í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”.
    - (ì˜ˆì‹œ) "ê±°ì¹œ íŒŒë„ê°€ ëª°ì•„ì¹˜ê³  ë±ƒì‚¬ëŒë“¤ì€ ì œë¬¼ì„ ì›í–ˆë‹¤. ì¹˜ë§ˆë¥¼ ë’¤ì§‘ì–´ì“°ê³  ë±ƒë¨¸ë¦¬ì— ì„  ì‹¬ì²­."

    **4ë‹¨ê³„: ì ˆë‹¨ì‹ ê³µ (The Cut) - "ê°€ì¥ ê¶ê¸ˆí•  ë•Œ ëŠê¸°"**
    - **ëª©í‘œ:** ë’·ë‚´ìš©ì´ ê¶ê¸ˆí•´ì„œ ë¯¸ì¹˜ê²Œ ë§Œë“¤ê¸°.
    - **ë°©ë²•:** ê²°ì •ì ì¸ í–‰ë™(ë¬¸ ì—´ê¸°, ì í”„, ë¹„ëª… ë“±)ì´ë‚˜ ì ˆì²´ì ˆëª…ì˜ ìˆœê°„ì—ì„œ **í™”ë©´ì„ ì•”ì „(Black out)**ì‹œí‚¤ê±°ë‚˜ ì§ˆë¬¸ì„ ë˜ì§€ë©° ëë‚´ì„¸ìš”.
    - **ì ˆëŒ€ ê¸ˆì§€:** ìœ„ê¸°ì˜ ê²°ê³¼ë‚˜ í•´ê²°ì±…ì˜ ì„±ê³µ ì—¬ë¶€ë¥¼ ë³´ì—¬ì£¼ì§€ ë§ˆì„¸ìš”.
    - (ì˜ˆì‹œ) "ëª¸ì„ ë˜ì§€ë ¤ë˜ ê·¸ ìˆœê°„, ë¬¼ì†ì—ì„œ ë¬´ì–¸ê°€ë¥¼ ë³´ì•˜ë‹¤. ê³¼ì—° ê·¸ë…€ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì€?"

    [ **í™”ì ë°°ì • ê·œì¹™**]
    1. **ìºë¦­í„° ëª©ë¡**: ì•„ë˜ IDë¥¼ `speaker` í•„ë“œì— ì‚¬ìš©í•˜ì„¸ìš”.
       {char_list_str}
    2. **ìš°ì„ ìˆœìœ„**: ì§€ë¬¸(ë‚˜ë ˆì´ì…˜)ê³¼ ëŒ€ì‚¬("")ê°€ ì„ì—¬ ìˆë‹¤ë©´, ë°˜ë“œì‹œ **ëŒ€ì‚¬ í™”ìì˜ ID**ë¥¼ ì ìœ¼ì„¸ìš”.
    3. **Narrator**: ìˆœìˆ˜ ìƒí™© ì„¤ëª…ì´ë‚˜ ì˜ˆê³ í¸ì˜ ë§ˆì§€ë§‰ ì§ˆë¬¸(ë©˜íŠ¸)ì¼ ë•Œë§Œ `narrator`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.

    [ ë¬¸ì¥ ë° í¸ì§‘ ê·œì¹™]
    1. **Source Page**: ëª¨ë“  ë¬¸ì¥ì€ ê·¼ê±°ê°€ ë˜ëŠ” ì›ë¬¸ì˜ í˜ì´ì§€ ë²ˆí˜¸ë¥¼ `source_page`ì— ì ì–´ì•¼ í•©ë‹ˆë‹¤. (ë§ˆì§€ë§‰ ë©˜íŠ¸ë§Œ 0 í—ˆìš©)
    2. **í¼ì¹¨ë©´ ì œí•œ**: ê°™ì€ í˜ì´ì§€(í˜¹ì€ í¼ì¹¨ë©´)ì—ì„œ ëŒ€ì‚¬ë¥¼ 3ê°œ ì´ìƒ ì—°ì†ìœ¼ë¡œ ê°€ì ¸ì˜¤ì§€ ë§ˆì„¸ìš”. ì§€ë£¨í•¨ì„ í”¼í•˜ê¸° ìœ„í•´ ì¥ë©´ì„ ë¹ ë¥´ê²Œ ì „í™˜í•˜ì„¸ìš”.
    3. **ìœ¡í•˜ì›ì¹™ í•„ìˆ˜ (Who/What/How)**: ë¬¸ì¥ë§Œ ë³´ê³ ë„ ìƒí™©ì´ ì´í•´ë˜ë„ë¡ ì£¼ì–´ì™€ ëª©ì ì–´ë¥¼ ëª…í™•íˆ í•˜ì„¸ìš”. "ê·¸ê²ƒì„ ë³´ì•˜ì–´ìš”" ëŒ€ì‹  "ì² ìˆ˜ëŠ” í”¼ ë¬»ì€ ì¹¼ì„ ë³´ì•˜ìŠµë‹ˆë‹¤"ì²˜ëŸ¼ **ëˆ„ê°€, ë¬´ì—‡ì„, ì–´ë–»ê²Œ í–ˆëŠ”ì§€** êµ¬ì²´ì ìœ¼ë¡œ ì„œìˆ í•´ì•¼ í•©ë‹ˆë‹¤.
    4. **ì˜ì„±ì–´ ì¢…ê²° ê¸ˆì§€**: "í’ë©!", "ì¿µ!" ê°™ì€ ì˜ì„±ì–´ë¡œ ë¬¸ì¥ì„ ëë‚´ì§€ ë§ˆì„¸ìš”. ë°˜ë“œì‹œ "ì‹¬ì²­ì´ ì¸ë‹¹ìˆ˜ì— í’ë© ë¹ ì¡ŒìŠµë‹ˆë‹¤", "ë¬¸ì´ ì¿µ í•˜ê³  ë‹«í˜”ì–´ìš”"ì™€ ê°™ì´ **í–‰ë™ì„ ë¬˜ì‚¬í•˜ëŠ” ì„œìˆ ì–´**ë¡œ ë¬¸ì¥ì„ ì™„ê²° ì§€ìœ¼ì„¸ìš”.

    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "subtitles": [
            {{"text": "(1ë‹¨ê³„) ë–¡ í•˜ë‚˜ ì£¼ë©´ ì•ˆ ì¡ì•„ë¨¹ì§€! ì–´í¥!", "speaker": "char_03", "source_page": 12}},
            {{"text": "(2ë‹¨ê³„) ì—„ë§ˆëŠ” ê³ ê°œ ë‹¤ì„¯ ê°œë¥¼ ë„˜ì–´ì•¼ í–ˆì§€ë§Œ, í˜¸ë‘ì´ëŠ” ë–¡ë„ ëª©ìˆ¨ë„ ì•—ì•„ê°€ ë²„ë ¸ìŠµë‹ˆë‹¤.", "speaker": "narrator", "source_page": 4}},
            {{"text": "(3ë‹¨ê³„) ì—„ë§ˆ ì˜·ì„ ì…ì€ í˜¸ë‘ì´ê°€ ë¬¸ì„ ë‘ë“œë ¸ì–´ìš”. 'ì–˜ë“¤ì•„ ì—„ë§ˆ ì™”ë‹¤'", "speaker": "narrator", "source_page": 16}},
            {{"text": "ë¬¸êµ¬ë©ìœ¼ë¡œ ê±°ì¹œ ì†ì´ ì‘¥ ë“¤ì–´ì™”ê³ , ì˜¤ëˆ„ì´ëŠ” ë’·ë¬¸ìœ¼ë¡œ ë„ë§ì³ ë‚˜ë¬´ ìœ„ë¡œ ì˜¬ë¼ê°”ìŠµë‹ˆë‹¤.", "speaker": "narrator", "source_page": 20}},
            {{"text": "(4ë‹¨ê³„) ì©ì€ ë™ì•„ì¤„ì¼ì§€ë„ ëª¨ë¥´ëŠ” ìƒí™©! ê³¼ì—° ì˜¤ëˆ„ì´ì˜ ìš´ëª…ì€?", "speaker": "narrator", "source_page": 0}}
        ],
        "estimated_duration": "ì˜ˆìƒ ì‹œê°„",
        "comment": "4ë‹¨ê³„ ê³µì‹ì´ ì–´ë–»ê²Œ ì ìš©ë˜ì—ˆëŠ”ì§€ ê°„ëµ ì„¤ëª…"
    }}
    """
    
    # ì›ë¬¸ ì „ì²´ë¥¼ ì°¸ê³  ìë£Œë¡œ ì œê³µ
    user_content = f"""
    [ì°¸ê³  ìë£Œ 1: ì „ì²´ ì›ë¬¸ í…ìŠ¤íŠ¸ (Context & Facts - ìš”ì•½ ë‹¨ê³„ì—ì„œ í™œìš©)]
    {full_text}

    [ì°¸ê³  ìë£Œ 2: ì˜ˆê³ í¸ì˜ í•µì‹¬ í•˜ì´ë¼ì´íŠ¸ êµ¬ê°„ (Build-up ë‹¨ê³„ì—ì„œ ì§‘ì¤‘ í™œìš©)]
    {target_text}
    """

    response = client.chat.completions.create(
        model="gpt-5.2", # ê¸´ í…ìŠ¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•´ gpt-5.2 ê¶Œì¥
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_content}
        ],
        response_format={"type": "json_object"}
    )
    
    return json.loads(response.choices[0].message.content)
        
# --------------------------------
# [Step 3 Helper] ì¥ë©´ ë²ˆí˜¸(Scene No) ìë™ í• ë‹¹ í•¨ìˆ˜
# --------------------------------
def assign_scene_numbers(subtitles):
    """
    ê·œì¹™:
    1. source_pageê°€ 0 (ìš”ì•½)ì´ë©´: ë¬´ì¡°ê±´ ìƒˆë¡œìš´ ì¥ë©´ ë²ˆí˜¸ ë¶€ì—¬ (ë¹ ë¥¸ ì»· ì „í™˜)
    2. source_pageê°€ 1 ì´ìƒ (ë³¸ë¬¸)ì´ë©´: 
       - ì§ì „ ëŒ€ì‚¬ì™€ í˜ì´ì§€ê°€ ê°™ìœ¼ë©´ -> ê°™ì€ ì¥ë©´ ë²ˆí˜¸ ìœ ì§€ (ê·¸ë£¹í•‘)
       - í˜ì´ì§€ê°€ ë‹¤ë¥´ë©´ -> ìƒˆë¡œìš´ ì¥ë©´ ë²ˆí˜¸ ë¶€ì—¬
    """
    if not subtitles:
        return subtitles
        
    scene_counter = 1
    last_page = -1
    
    for i, item in enumerate(subtitles):
        try:
            current_page = int(item.get("source_page", 0))
        except:
            current_page = 0
            
        if i == 0:
            # ì²« ë²ˆì§¸ í•­ëª©
            item["scene_no"] = scene_counter
            last_page = current_page
            continue

        # ë¡œì§ ì ìš©
        if current_page == 0:
            # ìš”ì•½ íŒŒíŠ¸ëŠ” ë¬´ì¡°ê±´ ì»·ì„ ë‚˜ëˆ” (ì§€ë£¨í•˜ì§€ ì•Šê²Œ)
            scene_counter += 1
            item["scene_no"] = scene_counter
            
        else:
            # ë³¸ë¬¸ íŒŒíŠ¸
            if current_page == last_page:
                # í˜ì´ì§€ê°€ ê°™ìœ¼ë©´ ê°™ì€ ì¥ë©´ ë²ˆí˜¸ ê³µìœ  (Merge íš¨ê³¼)
                item["scene_no"] = scene_counter
            else:
                # í˜ì´ì§€ê°€ ë‹¬ë¼ì§€ë©´ ìƒˆ ì¥ë©´
                scene_counter += 1
                item["scene_no"] = scene_counter
        
        last_page = current_page
        
    return subtitles


# --------------------------------
# [Step 3 Helper] ë…ë¦½í˜• í›…(Hook) ìƒì„± í•¨ìˆ˜
# --------------------------------
def generate_standalone_hooks(target_text: str, full_text: str, char_info: dict):
    """
    ì „ì²´ ë‚´ìš©ê³¼ í•µì‹¬ êµ¬ê°„ì„ ë¶„ì„í•˜ì—¬, ì˜ˆê³ í¸ì˜ ì˜¤í”„ë‹(ë˜ëŠ” ì—”ë”©)ìœ¼ë¡œ ì“¸ ìˆ˜ ìˆëŠ”
    'ê°€ì¥ ê°•ë ¬í•œ í•œ ë°©(Hook)' í›„ë³´ 3ê°€ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """
    
    # ìºë¦­í„° ì •ë³´ ë¬¸ìì—´ ë³€í™˜
    char_list_str = ""
    if char_info and "characters" in char_info:
        for c in char_info["characters"]:
            char_list_str += f"- {c['name']} (ID: {c['id']}, ì„±ë³„: {c['gender']}, ë§íˆ¬: {c['tone']})\n"

    system_prompt = f"""
    ë‹¹ì‹ ì€ ì˜í™” ì˜ˆê³ í¸ì˜ **'ë„ì…ë¶€(Hook)' ì „ë¬¸ ì¹´í”¼ë¼ì´í„°**ì…ë‹ˆë‹¤.
    ì´ì•¼ê¸° ì „ì²´ì—ì„œ ì‹œì²­ìì˜ ì‹œì„ ì„ ë‹¨ 3ì´ˆ ë§Œì— ì‚¬ë¡œì¡ì„ ìˆ˜ ìˆëŠ” **ê°€ì¥ ìê·¹ì ì´ê³  ì¶©ê²©ì ì¸ ì¥ë©´(ëŒ€ì‚¬)** 3ê°€ì§€ë¥¼ ì°¾ìœ¼ì„¸ìš”.

    [ì‘ì—… ëª©í‘œ]
    - ì˜ˆê³ í¸ì˜ ë§¨ ì•(ì˜¤í”„ë‹)ì´ë‚˜ ë§¨ ë’¤(ì ˆë‹¨ì‹ ê³µ)ì— ë¶™ì¼ ìˆ˜ ìˆëŠ” ì§§ê³  ê°•ë ¬í•œ ì”¬ì„ ë§Œë“­ë‹ˆë‹¤.
    - ë¬¸ë§¥ ì„¤ëª…ì€ ìµœì†Œí™”í•˜ê³ , **ëŒ€ì‚¬ ìœ„ì£¼**ë‚˜ **ê¸´ë°•í•œ ìƒí™© ë¬˜ì‚¬**ì— ì§‘ì¤‘í•˜ì„¸ìš”.

    [í›„ë³´ 3ê°€ì§€ êµ¬ì„±]
    1. **Option A (The Shock)**: ê°€ì¥ ì¶©ê²©ì ì¸ ëŒ€ì‚¬ë‚˜ ì‚¬ê±´ì˜ ì‹œì‘ì .
    2. **Option B (The Question)**: í˜¸ê¸°ì‹¬ì„ ìœ ë°œí•˜ëŠ” ë¯¸ìŠ¤í„°ë¦¬í•œ ìƒí™©.
    3. **Option C (The Action)**: ê¸´ë°•í•œ ë„ì£¼, ë¹„ëª…, ì¶©ëŒ ë“± ì—­ë™ì ì¸ ìˆœê°„.

    [ğŸ‘¥ í™”ì ë°°ì •]
    - ì•„ë˜ ìºë¦­í„° IDë¥¼ ì‚¬ìš©í•˜ì—¬ `speaker`ë¥¼ ì§€ì •í•˜ì„¸ìš”.
    {char_list_str}

    [ë°˜í™˜ í˜•ì‹ - JSON]
    {{
        "hooks": [
            {{
                "id": "A",
                "type": "ì¶©ê²©ì  ë°˜ì „í˜•",
                "content": [
                    {{"text": "ê³µì–‘ë¯¸ ì‚¼ë°± ì„ì— ì €ë¥¼ ì¸ë‹¹ìˆ˜ì— ë˜ì ¸ì£¼ì„¸ìš”.", "speaker": "char_01", "source_page": 20}},
                    {{"text": "ë­ë¼ê³ ? ì‹¬ì²­ì´ ë„¤ê°€ ì œë¬¼ì´ ë˜ê² ë‹¤ê³ ?", "speaker": "char_02", "source_page": 21}}
                ]
            }},
            {{
                "id": "B",
                "type": "ë¯¸ìŠ¤í„°ë¦¬í˜•",
                "content": [ ... ]
            }},
            {{
                "id": "C",
                "type": "ì•¡ì…˜/ìœ„ê¸°í˜•",
                "content": [ ... ]
            }}
        ]
    }}
    """
    
    user_content = f"""
    [í•µì‹¬ í•˜ì´ë¼ì´íŠ¸ êµ¬ê°„]
    {target_text}

    [ì „ì²´ ì›ë¬¸ ì°¸ê³ ]
    {full_text}
    """

    response = client.chat.completions.create(
        model="gpt-5.2", 
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_content}
        ],
        response_format={"type": "json_object"}
    )
    
    return json.loads(response.choices[0].message.content)

# =========================================================
# [Step 3 Helper] ì—°ì†ëœ ì”¬ ì••ì¶• ë¡œì§ (3ê°œ ì´ìƒ -> 2ê°œ)
# =========================================================
def compress_consecutive_scenes(subtitles):
    """
    ê°™ì€ source_pageë¥¼ ê°€ì§„ ì—°ì†ëœ ì”¬ì´ 3ê°œ ì´ìƒì¼ ê²½ìš°,
    ë¬¸ì¥ ë‹¨ìœ„ë¡œ ìª¼ê°œì–´ ê¸€ì ìˆ˜ ê· í˜•ì´ ê°€ì¥ ì˜ ë§ëŠ” 2ê°œì˜ ì”¬ìœ¼ë¡œ ì••ì¶•í•©ë‹ˆë‹¤.
    """
    if not subtitles:
        return []

    compressed_subs = []
    
    # 1. ì—°ì†ëœ ê°™ì€ í˜ì´ì§€ ê·¸ë£¹í•‘
    groups = []
    if not subtitles:
        return []
        
    current_group = [subtitles[0]]
    
    for i in range(1, len(subtitles)):
        curr = subtitles[i]
        prev = subtitles[i-1]
        
        # source_pageê°€ ìˆê³  ì„œë¡œ ê°™ë‹¤ë©´ ê·¸ë£¹ì— ì¶”ê°€
        curr_page = curr.get("source_page")
        prev_page = prev.get("source_page")
        
        if curr_page is not None and curr_page == prev_page:
            current_group.append(curr)
        else:
            groups.append(current_group)
            current_group = [curr]
    groups.append(current_group)

    # 2. ê·¸ë£¹ë³„ ì²˜ë¦¬
    for group in groups:
        # 3ê°œ ë¯¸ë§Œì´ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
        if len(group) < 3:
            compressed_subs.extend(group)
            continue
            
        # 3ê°œ ì´ìƒì´ë©´ 2ê°œë¡œ ì••ì¶• ë¡œì§ ì‹œì‘
        # (1) ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„í•´ (ì›ë˜ í™”ì ì •ë³´ ë³´ì¡´)
        sentence_units = []
        for item in group:
            text = item.get("text", "")
            speaker = item.get("speaker", "narrator")
            # ë¬¸ì¥ ë¶„ë¦¬ (ë§ˆì¹¨í‘œ, ë¬¼ìŒí‘œ, ëŠë‚Œí‘œ ë’¤ ê³µë°± ê¸°ì¤€, ë”°ì˜´í‘œ ë‚´ë¶€ëŠ” ë³´ì¡´ ë…¸ë ¥)
            # ê°„ë‹¨í•˜ê²Œ ì •ê·œì‹ìœ¼ë¡œ ë¶„ë¦¬ í›„ ë¹ˆ ë¬¸ìì—´ ì œê±°
            # (?<=[.?!])\s+ : ë¬¸ì¥ë¶€í˜¸ ë’¤ ê³µë°± ê¸°ì¤€ ë¶„ë¦¬
            sentences = re.split(r'(?<=[.?!])\s+', text)
            for s in sentences:
                clean_s = s.strip()
                if clean_s:
                    sentence_units.append({
                        "text": clean_s,
                        "origin_speaker": speaker,
                        "origin_item": item
                    })
        
        if not sentence_units: # ì˜ˆì™¸ ì²˜ë¦¬
            compressed_subs.extend(group)
            continue

        # (2) ìµœì ì˜ ë¶„í•  ì§€ì  ì°¾ê¸° (ê¸€ì ìˆ˜ ì°¨ì´ ìµœì†Œí™”)
        total_len = sum(len(u["text"]) for u in sentence_units)
        best_split_idx = 1
        min_diff = total_len  # ì´ˆê¸°ê°’: ì•„ì£¼ í° ìˆ˜
        
        # ìµœì†Œ 1ë¬¸ì¥ì”©ì€ ê°€ì ¸ê°€ì•¼ í•˜ë¯€ë¡œ range(1, len)
        for i in range(1, len(sentence_units)):
            left_len = sum(len(u["text"]) for u in sentence_units[:i])
            right_len = total_len - left_len
            diff = abs(left_len - right_len)
            
            if diff < min_diff:
                min_diff = diff
                best_split_idx = i
                
        # (3) 2ê°œì˜ ì”¬ìœ¼ë¡œ ë³‘í•© ìƒì„±
        # ì™¼ìª½ íŒŒíŠ¸ / ì˜¤ë¥¸ìª½ íŒŒíŠ¸
        parts = [sentence_units[:best_split_idx], sentence_units[best_split_idx:]]
        
        for part in parts:
            if not part: continue
            
            # í…ìŠ¤íŠ¸ í•©ì¹˜ê¸°
            merged_text = " ".join([u["text"] for u in part])
            
            # í™”ì ê²°ì • ë¡œì§:
            # 1. íŒŒíŠ¸ ë‚´ì— 'narrator'ê°€ ì•„ë‹Œ ìºë¦­í„°ê°€ ìˆë‹¤ë©´ ê·¸ ìºë¦­í„°ë¥¼ ìš°ì„  ì‚¬ìš©
            # 2. ì—¬ëŸ¬ ìºë¦­í„°ê°€ ì„ì—¬ ìˆë‹¤ë©´, ì²« ë²ˆì§¸ ë“±ì¥í•œ ìºë¦­í„°(ë˜ëŠ” ë¹„ì¤‘ í° ìºë¦­í„°) ì‚¬ìš©
            # 3. ëª¨ë‘ narratorë¼ë©´ narrator ì‚¬ìš©
            
            final_speaker = "narrator"
            # ë‚˜ë ˆì´í„°ê°€ ì•„ë‹Œ í™”ìë“¤ì„ ìˆ˜ì§‘
            char_speakers = [u["origin_speaker"] for u in part if "narrator" not in u["origin_speaker"].lower()]
            
            if char_speakers:
                # ìºë¦­í„°ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ê·¸ ìºë¦­í„°ë¥¼ í™”ìë¡œ (ì²«ë²ˆì§¸ ë°œê²¬ëœ ìºë¦­í„° ê¸°ì¤€)
                final_speaker = char_speakers[0]
            else:
                # ìºë¦­í„°ê°€ ì—†ìœ¼ë©´ ë‚˜ë ˆì´í„° ìœ ì§€
                final_speaker = "narrator"

            # ë©”íƒ€ ë°ì´í„°ëŠ” í•´ë‹¹ íŒŒíŠ¸ì˜ ì²« ë²ˆì§¸ ì›ë³¸ ì•„ì´í…œì˜ ê²ƒì„ ì¼ë¶€ ìŠ¹ê³„
            base_item = part[0]["origin_item"]
            
            new_scene = {
                "speaker": final_speaker,
                "text": merged_text,
                "source_page": base_item.get("source_page"),
                "emotion": base_item.get("emotion", "neutral") # ê°ì •ì€ ì²« ë¶€ë¶„ ë”°ë¼ê°
            }
            compressed_subs.append(new_scene)

    return compressed_subs

# [step 3 Helper] ë²„ì „ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬)
def get_sorted_versions(base_dir, safe_name, mode):
    """
    ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ëœ ë²„ì „ ìˆ«ì ë¦¬ìŠ¤íŠ¸ì™€ íŒŒì¼ ê²½ë¡œ ë§µì„ ë°˜í™˜
    Returns: 
        sorted_versions: [3, 2, 1] 
        version_map: {3: Path(..v3..), 2: Path(..v2..)}
    """
    pattern = re.compile(rf"script_{re.escape(safe_name)}_{re.escape(mode)}_v(\d+)\.json")
    version_map = {}
    
    if base_dir.exists():
        for f in base_dir.iterdir():
            match = pattern.match(f.name)
            if match:
                ver = int(match.group(1))
                version_map[ver] = f
                
    # ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ìµœì‹ ì´ 0ë²ˆ ì¸ë±ìŠ¤ì— ì˜¤ë„ë¡)
    sorted_versions = sorted(version_map.keys(), reverse=True)
    return sorted_versions, version_map

# =========================================================
# [step 4 Helper] (Page + Speaker) ê¸°ë°˜ ì •ë°€ ë§¤ì¹­ í•¨ìˆ˜(í™”ì ë³„ í”„ë¡¬í”„íŠ¸ ì œì‘ ìš©)
# =========================================================
def find_context_by_structure(target_text, target_speaker_raw, target_page, dialogue_map_data):
    """
    1. Pageì™€ Speaker IDê°€ ì¼ì¹˜í•˜ëŠ” í›„ë³´êµ°ì„ ë¨¼ì € ì¶”ë¦½ë‹ˆë‹¤.
    2. í›„ë³´êµ° ë‚´ì—ì„œ í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ê°€ ê°€ì¥ ë†’ì€ Contextë¥¼ ì°¾ìŠµë‹ˆë‹¤.
    """
    from difflib import SequenceMatcher

    # 1. í™”ì ID ì¶”ì¶œ (ì˜ˆ: "char_01 (í¥ë¶€) young_male" -> "char_01")
    # ë‚˜ë ˆì´í„°ëŠ” contextê°€ ì—†ìœ¼ë¯€ë¡œ ì œì™¸
    if not target_speaker_raw or "narrator" in target_speaker_raw.lower():
        return ""
    
    target_id = target_speaker_raw.split(" ")[0].strip() # "char_01"
    
    # 2. í›„ë³´êµ° í•„í„°ë§ (Pageì™€ Speakerê°€ ê°™ì€ ê²ƒë§Œ!)
    candidates = []
    for d in dialogue_map_data:
        # Step 1.5 ë°ì´í„°ì˜ page_numê³¼ speaker_id
        src_page = int(d.get("page_num", -1))
        src_id = d.get("speaker_id", "")
        
        # í˜ì´ì§€ ë§¤ì¹­ (ëŒ€ë³¸ì˜ pageê°€ 0ì´ë©´ ë§¤ì¹­ ë¶ˆê°€)
        if target_page > 0 and src_page == target_page:
            if src_id == target_id:
                candidates.append(d)
    
    # 3. í›„ë³´ê°€ ì—†ìœ¼ë©´? (í˜ì´ì§€ê°€ ë‹¬ë¼ì¡Œê±°ë‚˜ í™”ìê°€ ë°”ë€ ê²½ìš°) -> ì „ì²´ ê²€ìƒ‰ìœ¼ë¡œ í™•ì¥ (Fallback)
    if not candidates:
        # í˜ì´ì§€ ì •ë³´ê°€ í‹€ë ¸ì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ, í™”ì IDë§Œ ê°™ì€ ê²ƒ ì¤‘ì—ì„œë¼ë„ ì°¾ìŒ
        candidates = [d for d in dialogue_map_data if d.get("speaker_id") == target_id]

    if not candidates:
        return "" # í•´ë‹¹ í™”ìì˜ ë°ì´í„°ê°€ ì•„ì˜ˆ ì—†ìŒ

    # 4. í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ë¹„êµ (í›„ë³´êµ° ë‚´ì—ì„œ)
    best_context = ""
    highest_ratio = 0.0
    
    # ê³µë°± ì œê±° ì •ê·œí™”
    def normalize(s):
        return re.sub(r"\s+", "", str(s)).strip()
    
    target_norm = normalize(target_text)

    for cand in candidates:
        origin_quote = cand.get("quote", "")
        origin_norm = normalize(origin_quote)
        
        # ì™„ì „ ì¼ì¹˜ (Lucky!)
        if target_norm == origin_norm:
            return cand.get("context", "")
        
        # ìœ ì‚¬ë„ ê³„ì‚°
        ratio = SequenceMatcher(None, target_norm, origin_norm).ratio()
        
        if ratio > highest_ratio:
            highest_ratio = ratio
            best_context = cand.get("context", "")
            
    # ìœ ì‚¬ë„ê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´(ì˜ˆ: 0.3 ë¯¸ë§Œ) ì—‰ëš±í•œ ê±¸ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìœ¼ë‹ˆ ì»¤íŠ¸ë¼ì¸ ì„¤ì •
    if highest_ratio < 0.3: 
        return ""

    return best_context

# --------------------------------
# [step 4 helper] ì˜¤ë””ì˜¤ ë³‘í•©í•˜ê¸°
# --------------------------------
def merge_audio_files(audio_paths: list, output_path: str):
    """
    ì—¬ëŸ¬ ê°œì˜ ì˜¤ë””ì˜¤ íŒŒì¼ ê²½ë¡œë¥¼ ë°›ì•„ í•˜ë‚˜ë¡œ í•©ì³ì„œ ì €ì¥í•©ë‹ˆë‹¤.
    """
    clips = []
    try:
        for p in audio_paths:
            if p and os.path.exists(p):
                clips.append(AudioFileClip(str(p)))
        
        if clips:
            final_clip = concatenate_audioclips(clips)
            final_clip.write_audiofile(output_path, logger=None) # logger=Noneìœ¼ë¡œ ì½˜ì†” ì¶œë ¥ ì–µì œ
            return True
        return False
    except Exception as e:
        print(f"ì˜¤ë””ì˜¤ ë³‘í•© ì¤‘ ì˜¤ë¥˜: {e}")
        return False
    finally:
        # ë¦¬ì†ŒìŠ¤ í•´ì œ
        for clip in clips:
            clip.close()

# [step 4 Helper] ëŒ€ë³¸_ìŒì„± ë²„ì „ í´ë” íŒŒì‹± í•¨ìˆ˜ 
def get_tts_versions_v2(base_dir):
    """
    í´ë”ëª…ì´ 'v{script_ver}_{audio_ver}' í˜•ì‹ì„ ê¸°ë³¸ìœ¼ë¡œ í•˜ë˜,
    ë’¤ì— ëª¨ë¸ëª…(_clova ë“±)ì´ ë¶™ì–´ë„ ì•ì˜ ìˆ«ì 2ê°œë¥¼ ê¸°ì¤€ìœ¼ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
    
    Returns:
        sorted_list: [(s_ver, a_ver), ...] (ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬)
        path_map: {(s_ver, a_ver): Pathê°ì²´}
    """
    version_map = {}
    
    if base_dir.exists():
        for item in base_dir.iterdir():
            if item.is_dir() and item.name.startswith("v"):
                # ì •ê·œì‹ ëŒ€ì‹  split ì‚¬ìš©
                # v1_1_clova -> ['v1', '1', 'clova']
                parts = item.name.split("_")
                
                # ìµœì†Œ 2ë©ì–´ë¦¬(vëŒ€ë³¸, ìŒì„±) ì´ìƒì´ë©´ ìœ íš¨í•œ í´ë”ë¡œ ê°„ì£¼
                if len(parts) >= 2:
                    try:
                        s_ver = int(parts[0].replace("v", "")) # v1 -> 1
                        a_ver = int(parts[1])                  # 1
                        
                        # manifest.jsonì´ ìˆì–´ì•¼ ìœ íš¨ ë°ì´í„°ë¡œ ì¸ì •
                        if (item / "manifest.json").exists():
                            # ë§µì— ì €ì¥ (ë™ì¼ ë²„ì „ì´ ì—¬ëŸ¬ ê°œë©´ ë‚˜ì¤‘ ê²ƒì´ ë®ì–´ì¨ì§€ì§€ë§Œ,
                            # ë³´í†µ ë²„ì „ ë²ˆí˜¸ë¥¼ ì¦ê°€ì‹œí‚¤ë¯€ë¡œ í° ë¬¸ì œ ì—†ìŠµë‹ˆë‹¤)
                            version_map[(s_ver, a_ver)] = item
                            
                    except ValueError:
                        continue # ìˆ«ìê°€ ì•„ë‹ˆë©´ íŒ¨ìŠ¤ (ì˜ˆ: v_temp ë“±)
    
    # ì •ë ¬ ê¸°ì¤€: ëŒ€ë³¸ ë²„ì „(ë‚´ë¦¼ì°¨ìˆœ) -> ìŒì„± ë²„ì „(ë‚´ë¦¼ì°¨ìˆœ)
    sorted_versions = sorted(version_map.keys(), key=lambda x: (x[0], x[1]), reverse=True)
    return sorted_versions, version_map
# --------------------------------
# [Step 5 Helper] ì´ë¯¸ì§€ í•„í„°ë§ ë° í…ìŠ¤íŠ¸ íŒŒì‹±
# --------------------------------
def load_filtered_images(folder_path: Path):
    """
    í´ë” ë‚´ì˜ PNG íŒŒì¼ì„ ì´ë¦„ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë’¤,
    ì• 4ì¥(í‘œì§€, ë‚´ì§€ ë“±)ê³¼ ë’¤ 3ì¥(ë’·í‘œì§€ ë“±)ì„ ì œì™¸í•œ ìœ íš¨ ì´ë¯¸ì§€ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    # 1. ëª¨ë“  PNG íŒŒì¼ ê°€ì ¸ì˜¤ê¸°
    all_images = sorted(list(folder_path.glob("*.png")))
    
    # 2. ì˜ˆì™¸ ì²˜ë¦¬: ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ì ì„ ê²½ìš°
    if len(all_images) <= 7:
        return all_images # í•„í„°ë§ ì—†ì´ ë°˜í™˜ (ì˜¤ë¥˜ ë°©ì§€)
        
    # 3. ì• 4ì¥, ë’¤ 3ì¥ ì œì™¸ (Slicing)
    # 0,1,2,3 ì œì™¸ -> 4ë¶€í„° ì‹œì‘
    # ë’¤ì—ì„œ 3ê°œ ì œì™¸ -> -3ê¹Œì§€
    valid_images = all_images[4:-3]
    
    return valid_images

def parse_book_text_by_page(txt_path: Path):
    """
    TXT íŒŒì¼ ì „ì²´ë¥¼ ì½ì–´, í˜ì´ì§€ ë²ˆí˜¸ë¥¼ í‚¤(Key)ë¡œ í•˜ëŠ” í…ìŠ¤íŠ¸ ë”•ì…”ë„ˆë¦¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    Format: { 6: "6í˜ì´ì§€ ë‚´ìš©...", 7: "7í˜ì´ì§€ ë‚´ìš©..." }
    """
    if not txt_path.exists():
        return {}
        
    content = txt_path.read_text(encoding="utf-8")
    page_map = {}
    
    # ì •ê·œì‹: "--- Page ìˆ«ì ---" íŒ¨í„´ ì°¾ê¸°
    # (?s)ëŠ” .ì´ ì¤„ë°”ê¿ˆë„ í¬í•¨í•˜ê²Œ í•˜ëŠ” í”Œë˜ê·¸ (DOTALL)
    # (.*?)ëŠ” ë‹¤ìŒ "--- Page"ê°€ ë‚˜ì˜¤ê¸° ì „ê¹Œì§€ì˜ ë‚´ìš©ì„ ë¹„íƒìš•ì ìœ¼ë¡œ ìº¡ì²˜
    pattern = re.compile(r"--- Page (\d+) ---\n(.*?)(?=--- Page \d+ ---|$)", re.DOTALL)
    
    matches = pattern.findall(content)
    for pg_str, text in matches:
        try:
            pg_num = int(pg_str)
            page_map[pg_num] = text.strip()
        except:
            continue
            
    return page_map

def extract_page_num_from_filename(filename: str):
    """
    íŒŒì¼ëª…(page_006.png)ì—ì„œ ìˆ«ì(6)ë§Œ ì¶”ì¶œ
    """
    m = re.search(r"page_(\d+)", filename)
    if m:
        return int(m.group(1))
    return None



# --------------------------------
# [Step 6 Helper] í¼ì¹¨ë©´ ë¶„ì„ ë° ë§¤ì¹­ ë¡œì§
# --------------------------------
def analyze_spread_structure(candidates: list):
    """
    í˜ì´ì§€ë“¤ì„ 2ì¥ì”©(í¼ì¹¨ë©´) ë¬¶ì–´ì„œ êµ¬ì¡°ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤.
    - ê·œì¹™: (ì§ìˆ˜, í™€ìˆ˜)ë¥¼ í•˜ë‚˜ì˜ ì§ìœ¼ë¡œ ë´„ (ì˜ˆ: 6-7, 8-9)
    - ë°˜í™˜: { page_num: {"pair": pair_num, "has_text": bool, "is_spread": bool} }
    """
    spread_map = {}
    
    # page_num ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    sorted_pages = sorted(candidates, key=lambda x: x["page_num"])
    
    # ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜ (ë¹ ë¥¸ ì¡°íšŒë¥¼ ìœ„í•´)
    page_dict = {item["page_num"]: item for item in sorted_pages}
    
    # ê·¸ë£¹í•‘
    for i, item in enumerate(sorted_pages):
        pg = item["page_num"]
        raw_text = item["text"].strip()
        has_text = (item["text"] != "(í…ìŠ¤íŠ¸ ì—†ìŒ)" and len(raw_text) > 0)
        if i > 0:
            prev_item = sorted_pages[i-1]
            prev_text = prev_item["text"].strip()
            # ì•ì¥ê³¼ í…ìŠ¤íŠ¸ê°€ ê°™ê³ , í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš° -> ë‚˜ëŠ” 'ê·¸ë¦¼ ì „ìš©'ìœ¼ë¡œ ì·¨ê¸‰
            if has_text and raw_text == prev_text:
                has_text = False # ê°•ì œ ì„¤ì •
        # ì§ê¿ ì°¾ê¸° (ì§ìˆ˜ë©´ +1, í™€ìˆ˜ë©´ -1)
        # ì˜ˆ: 6ì´ë©´ 7ì´ ì§ê¿, 7ì´ë©´ 6ì´ ì§ê¿
        if pg % 2 == 0: 
            pair_pg = pg + 1
        else:
            pair_pg = pg - 1
            
        pair_item = page_dict.get(pair_pg)
        
        spread_info = {
            "my_page": pg,
            "pair_page": pair_pg if pair_item else None,
            "has_text": has_text,
            "img_path": item["img_path"]
        }
        
        spread_map[pg] = spread_info
        
    return spread_map


# --------------------------------
# [Step 6 Helper] ì €ì‘ê¶Œ í˜ì´ì§€ë¥¼ ë°”íƒ•ìœ¼ë¡œ í‘œì§€ ì°¾ê¸°
# --------------------------------

def _norm(s: str) -> str:
    # ì¤„ë°”ê¿ˆ/ê³µë°±/íƒ­ ì œê±° + ì†Œë¬¸ìí™” (ë°°ì¹˜/ì¤„ë°”ê¿ˆ ì°¨ì´ í¡ìˆ˜)
    return re.sub(r"\s+", "", (s or "")).lower()

def find_cover_page_num(text_map: dict, candidates: list) -> int:
    """
    ì €ì‘ê¶Œ ë¬¸ë‹¨ì´ ìˆëŠ” í˜ì´ì§€ë¥¼ ì°¾ê³ , ê·¸ ë‹¤ìŒ ì¡´ì¬í•˜ëŠ” í˜ì´ì§€ë¥¼ í‘œì§€ë¡œ ë°˜í™˜.
    ì‹¤íŒ¨í•˜ë©´ candidatesì˜ ì²« í˜ì´ì§€ë¡œ fallback.
    """
    if not candidates:
        return 5

    pages_sorted = sorted([c["page_num"] for c in candidates])
    # (1) ì €ì‘ê¶Œ ë¬¸ë‹¨ íŒë³„ìš© í‚¤ì›Œë“œë“¤ (ì¤„ë°”ê¿ˆ/ë¶™ì–´ì“°ê¸° ë¬´ê´€í•˜ê²Œ ê²€ì‚¬)
    # ìµœì†Œ ì„¸íŠ¸: All rights reserved + Published in Singapore
    # í•„ìš”í•˜ë©´ í‚¤ì›Œë“œ ì¶”ê°€ ê°€ëŠ¥
    kw1 = _norm("All rights reserved")
    kw2 = _norm("Published in Singapore")
    kw3 = _norm("HS PARTNERS PTE LTD")  # ì±…ë§ˆë‹¤ ë“¤ì–´ê°€ë©´ ë” ê°•í•˜ê²Œ íŒë³„

    copyright_pg = None
    for pg, txt in text_map.items():
        t = _norm(txt)
        # ì¡°ê±´ì€ ë„ˆë¬´ ë¹¡ì„¸ì§€ ì•Šê²Œ: kw1ê³¼ kw2ëŠ” í•„ìˆ˜, kw3ëŠ” ìˆìœ¼ë©´ ê°€ì‚°(ì„ íƒ)
        if (kw1 in t) and (kw2 in t):
            copyright_pg = pg
            # kw3ê¹Œì§€ í¬í•¨ëœ í˜ì´ì§€ë¥¼ ë” ìš°ì„ í•˜ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì„œ break ëŒ€ì‹  ìš°ì„ ìˆœìœ„ ì²˜ë¦¬ ê°€ëŠ¥
            break

    # (2) "ë‹¤ìŒ í˜ì´ì§€" ì°¾ê¸°: candidatesì— ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” ë‹¤ìŒ í˜ì´ì§€ë¡œ ì í”„
    if copyright_pg is not None:
        for pg in pages_sorted:
            if pg > copyright_pg:
                return pg

    # (3) fallback
    return pages_sorted[0]

# [step 6.5 Helper] í”„ë¦¬ë·° ë²„ì „ íŒŒì‹± (v{script}_{audio}_{preview})
def get_preview_versions(base_dir):
    version_map = {}
    if base_dir.exists():
        for item in base_dir.iterdir():
            if item.is_dir():
                # ì •ê·œì‹: v(S)_(A)_(P)
                match = re.match(r"^v(\d+)_(\d+)_(\d+)$", item.name)
                if match:
                    s, a, p = map(int, match.groups())
                    if (item / "manifest.json").exists():
                        version_map[(s, a, p)] = item
    # ì •ë ¬: S->A->P ë‚´ë¦¼ì°¨ìˆœ
    sorted_keys = sorted(version_map.keys(), key=lambda x: x, reverse=True)
    return sorted_keys, version_map


# [step 6.5, 8 Helper] ìë§‰ ìƒ‰ìƒ ë³€ê²½

def generate_dynamic_color_map(scripts):
    """
    ëŒ€ë³¸ì„ ë¶„ì„í•˜ì—¬ ë“±ì¥ì¸ë¬¼ë³„ë¡œ ê³ ìœ í•œ ë°ì€ ìƒ‰ìƒì„ ë°°ì •í•©ë‹ˆë‹¤.
    Returns: { "í™”ìì´ë¦„": "#HexCode", ... }
    """
    # 1. ì‹œì¸ì„±ì´ ì¢‹ì€ ë°ì€ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ë°°ê²½ì´ ì–´ë‘ìš¸ ë•Œ ì˜ ë³´ì´ëŠ” ìƒ‰)
    # (ë…¸ë‘, ë¯¼íŠ¸, í•‘í¬, í•˜ëŠ˜, ë¼ì„, ì˜¤ë Œì§€, ë¼ë²¤ë”, ì‚°í˜¸ìƒ‰ ë“±)
    palette = [
        "#FFD700", # Gold
        "#00FFFF", # Cyan
        "#FF69B4", # HotPink
        "#ADFF2F", # GreenYellow
        "#FFA500", # Orange
        "#D8BFD8", # Thistle (ì—°ë³´ë¼)
        "#F0E68C", # Khaki
        "#7FFFD4", # Aquamarine
        "#FF6347", # Tomato
        "#87CEFA", # LightSkyBlue
        "#EE82EE", # Violet
        "#98FB98", # PaleGreen
    ]
    
    # 2. ëŒ€ë³¸ì—ì„œ ê³ ìœ  í™”ì ì¶”ì¶œ
    unique_speakers = set()
    for s in scripts:
        spk = s.get("speaker", "narrator")
        unique_clips = str(spk).strip()
        unique_speakers.add(unique_clips)
        
    # 3. ìƒ‰ìƒ ë§¤í•‘ ìƒì„±
    color_map = {}
    
    # ë‚˜ë ˆì´í„° ê³„ì—´ì€ ë¬´ì¡°ê±´ í°ìƒ‰ ê³ ì •
    narrator_keys = ["narrator", "narration", "ë‚˜ë ˆì´ì…˜", "í•´ì„¤"]
    
    palette_idx = 0
    
    # ì •ë ¬í•˜ì—¬ í• ë‹¹ (ë§¤ë²ˆ ê°™ì€ ì‚¬ëŒì´ ê°™ì€ ìƒ‰ì„ ë°›ë„ë¡)
    for spk in sorted(list(unique_speakers)):
        # ë‚˜ë ˆì´í„° ì²´í¬
        is_narrator = any(n in spk.lower() for n in narrator_keys)
        
        if is_narrator:
            color_map[spk] = "white"
        else:
            # íŒ”ë ˆíŠ¸ì—ì„œ ìƒ‰ êº¼ë‚´ê¸° (ì‚¬ëŒì´ ë§ìœ¼ë©´ ë¡œí…Œì´ì…˜)
            assigned_color = palette[palette_idx % len(palette)]
            color_map[spk] = assigned_color
            palette_idx += 1
            
    return color_map


# [step 7 Helper] 3ë‹¨ ë²„ì „ í´ë” íŒŒì‹± (v{script}_{audio}_{video})
def get_video_versions_v3(base_dir):
    """
    í´ë”ëª…ì´ 'v{s}_{a}_{v}' í˜•ì‹ì¸ ê²ƒì„ ì°¾ì•„ íŒŒì‹±í•©ë‹ˆë‹¤.
    Returns:
        sorted_keys: [(s, a, v), ...] (ë‚´ë¦¼ì°¨ìˆœ)
        path_map: {(s, a, v): Pathê°ì²´}
    """
    version_map = {}
    
    if base_dir.exists():
        for item in base_dir.iterdir():
            if item.is_dir():
                # ì •ê·œì‹: v(ìˆ«ì)_(ìˆ«ì)_(ìˆ«ì)
                match = re.match(r"^v(\d+)_(\d+)_(\d+)$", item.name)
                if match:
                    s = int(match.group(1)) # ëŒ€ë³¸
                    a = int(match.group(2)) # ìŒì„±
                    v = int(match.group(3)) # ì˜ìƒ
                    
                    if (item / "manifest.json").exists():
                        version_map[(s, a, v)] = item
    
    # ì •ë ¬: S -> A -> V ìˆœì„œë¡œ ë‚´ë¦¼ì°¨ìˆœ
    sorted_keys = sorted(version_map.keys(), key=lambda x: (x[0], x[1], x[2]), reverse=True)
    return sorted_keys, version_map

# [step 8 Helper] 4ë‹¨ ë²„ì „ íŒŒì‹± (v{S}_{A}_{V}_{F})
def get_final_versions(base_dir):
    """
    í´ë”ëª…ì´ 'v{s}_{a}_{v}_{f}' í˜•ì‹ì¸ ê²ƒì„ ì°¾ì•„ íŒŒì‹±
    """
    version_map = {}
    if base_dir.exists():
        for item in base_dir.iterdir():
            if item.is_dir():
                # ì •ê·œì‹: v(S)_(A)_(V)_(F)
                match = re.match(r"^v(\d+)_(\d+)_(\d+)_(\d+)$", item.name)
                if match:
                    s, a, v, f = map(int, match.groups())
                    if (item / "manifest.json").exists():
                        version_map[(s, a, v, f)] = item
    
    # ì •ë ¬: S->A->V->F ë‚´ë¦¼ì°¨ìˆœ
    sorted_keys = sorted(version_map.keys(), key=lambda x: x, reverse=True)
    return sorted_keys, version_map

# --------------------------------
# 2. ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ (Render Function)
# --------------------------------

def run_text_analysis_mode(client, folder, txt_file):
    """
    app.pyì—ì„œ í˜¸ì¶œë˜ëŠ” ë©”ì¸ í•¨ìˆ˜ì…ë‹ˆë‹¤.
    :param client: OpenAI Client ê°ì²´
    :param folder: ì´ë¯¸ì§€ í´ë” Path ê°ì²´
    :param txt_file: í…ìŠ¤íŠ¸ íŒŒì¼ Path ê°ì²´
    """
    if "script_results" not in st.session_state:
        st.session_state["script_results"] = {} 
    st.info("ğŸ“œ ì „ì²´ ì¤„ê±°ë¦¬ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì˜ˆê³ í¸ ëŒ€ë³¸ì„ ë¨¼ì € ì‘ì„±í•©ë‹ˆë‹¤.")

    # 0. íŒŒì¼ í™•ì¸ ë° í…ìŠ¤íŠ¸ ë¡œë“œ
    if txt_file.exists():
        full_text = txt_file.read_text(encoding="utf-8")
        extracted_title = extract_title_from_filename(txt_file.name)
        with st.expander(f"ğŸ“„ ì›ë³¸ í…ìŠ¤íŠ¸ í™•ì¸ (ì¶”ì¶œ ì œëª©: {extracted_title})"):
            st.text_area("Full Text", full_text, height=200)
    else:
        st.error("TXT íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        st.stop()

    st.divider()


    # ì €ì¥ ê²½ë¡œ ì„¤ì • (text/tts.mp3/mp4)

    story_dir_name = txt_file.stem
    TEXT_OUT = Path("outputs") / story_dir_name / "TEXT"
    TEXT_OUT.mkdir(parents=True, exist_ok=True)
    # íŒŒì¼ëª… ì•ˆì „í•˜ê²Œ ë³€í™˜ (í™•ì¥ì ì œì™¸í•œ ì´ë¦„ ì‚¬ìš©)
    safe_name = Path(txt_file.name).stem
    paths = {
        "analysis":    TEXT_OUT / f"analysis_{safe_name}.json",
        "characters": TEXT_OUT / f"characters_{safe_name}.json",
        "segments": TEXT_OUT / f"segments_{safe_name}.json",
        "script":     TEXT_OUT / f"script_{safe_name}.json",
    }

    # -----------------------------------------
    # [Step 1] ë™í™” ë‚´ìš© ë¶„ì„
    # -----------------------------------------
    st.subheader("Step 1. ë™í™” ë‚´ìš© ë¶„ì„ ë° êµ¬ì¡°í™”")

    # 1. ì´ˆê¸° ì„¸ì…˜ ìƒíƒœ ë° íŒŒì¼ ê²½ë¡œ ì„¤ì •
    if "track_b_analysis" not in st.session_state:
        st.session_state.track_b_analysis = None

    analysis_file = paths["analysis"]

    # 2. ì €ì¥ëœ íŒŒì¼ì´ ìˆë‹¤ë©´ ìë™ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¤ê¸° (ì„¸ì…˜ì´ ë¹„ì–´ìˆì„ ë•Œë§Œ)
    if st.session_state.track_b_analysis is None and analysis_file.exists():
        try:
            with open(analysis_file, "r", encoding="utf-8") as f:
                st.session_state.track_b_analysis = json.load(f)
            st.toast("ğŸ“‚ ì €ì¥ëœ ë¶„ì„ ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.", icon="âœ…")
        except Exception as e:
            st.error(f"íŒŒì¼ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: {e}")

    # 3. ë¶„ì„ ë²„íŠ¼ ìƒíƒœ ê²°ì • 
    if st.session_state.track_b_analysis is None:
        btn_label_1 = "ğŸ” AI ë™í™” ë¶„ì„ ì‹œì‘"
        btn_type_1 = "primary"
    else:
        btn_label_1 = "ğŸ”„ ë‹¤ì‹œ ë¶„ì„í•˜ê¸° (ë®ì–´ì“°ê¸°)"
        btn_type_1 = "secondary"

    # 4. ë¶„ì„ ì‹¤í–‰ ë²„íŠ¼
    if st.button(btn_label_1, type=btn_type_1):
        with st.spinner(f"GPTê°€ '{extracted_title}' ì´ì•¼ê¸°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤..."):
            try:
                # AI ë¶„ì„ í•¨ìˆ˜ í˜¸ì¶œ (force run)
                result = analyze_story_structure(full_text, known_title=extracted_title)
                
                # íŒŒì¼ ì €ì¥ ë° ì„¸ì…˜ ì—…ë°ì´íŠ¸
                with open(analysis_file, "w", encoding="utf-8") as f:
                    json.dump(result, f, ensure_ascii=False, indent=4)
                
                st.session_state.track_b_analysis = result
                st.success("âœ… ë¶„ì„ ë° ì €ì¥ ì™„ë£Œ!")
                st.rerun()
            except Exception as e:
                st.error(f"ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    # ë¶„ì„ ê²°ê³¼ í™”ë©´ í‘œì‹œ
    if st.session_state.track_b_analysis:
        data = st.session_state.track_b_analysis
        col_t, col_m = st.columns([2, 1])
        with col_t: st.markdown(f"### ğŸ·ï¸ {data.get('title', extracted_title)}")
        with col_m: st.info(f"**ğŸ’¡ êµí›ˆ:** {data.get('moral', 'ì—†ìŒ')}")
        st.markdown("#### ğŸ“ ì „ì²´ ì¤„ê±°ë¦¬ ìš”ì•½")
        st.write(data.get("summary", ""))
        
        st.markdown("#### ğŸŒŠ ì´ì•¼ê¸° êµ¬ì¡° (ê¸°ìŠ¹ì „ê²° & í˜ì´ì§€ ë²”ìœ„)")
        structure = data.get("plot_structure", {})
        
        # íƒ­ êµ¬ì„±
        tab1, tab2, tab3, tab4 = st.tabs(["1. ë°œë‹¨ (Intro)", "2. ì „ê°œ (Dev)", "3. ìœ„ê¸°/ì ˆì • (Climax)", "4. ê²°ë§ (Res)"])
        
        # í—¬í¼ í•¨ìˆ˜: êµ¬ì¡° ë°ì´í„° í‘œì‹œ
        def display_phase_info(phase_data):
            if isinstance(phase_data, dict):
                # ìƒˆë¡œìš´ êµ¬ì¡° (Dict)
                s_page = phase_data.get("start_page", "?")
                e_page = phase_data.get("end_page", "?")
                st.markdown(f"**ğŸ“– Page Range:** `{s_page}p ~ {e_page}p`")
                st.write(phase_data.get("summary", "ë‚´ìš© ì—†ìŒ"))
            else:
                # êµ¬ë²„ì „ í˜¸í™˜ (String)
                st.write(phase_data)

        with tab1: 
            st.success("ğŸŒ± ì´ì•¼ê¸°ì˜ ì‹œì‘")
            display_phase_info(structure.get("introduction", {}))
        with tab2: 
            st.info("â˜ï¸ ì‚¬ê±´ì˜ ì „ê°œ")
            display_phase_info(structure.get("development", {}))
        with tab3: 
            st.warning("âš¡ ìœ„ê¸° ë° ì ˆì •")
            display_phase_info(structure.get("climax", {}))
        with tab4: 
            st.error("âœ¨ ê²°ë§")
            display_phase_info(structure.get("resolution", {}))

        st.divider()
        col_msg, col_btn = st.columns([3, 1])
        with col_msg: st.caption("ìœ„ ë¶„ì„ ë‚´ìš©ì´ ë§ë‹¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°€ì„¸ìš”.")
        with col_btn:
            if st.button("â¡ï¸ Step 1.5: ë“±ì¥ì¸ë¬¼ ë° í™”ì ë¶„ì„ "):
                st.session_state.track_b_step = 2
                st.rerun()

    # =========================================================
    # [Step 1.5] ë“±ì¥ì¸ë¬¼ ë° í™”ì ë¶„ì„ (Character & Speaker Analysis)
    # =========================================================
    # Step 1 ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆê±°ë‚˜, ì‚¬ìš©ìê°€ ìˆ˜ë™ìœ¼ë¡œ 1.5ë‹¨ê³„ë¥¼ ì—´ì—ˆì„ ë•Œ
    if st.session_state.get("track_b_analysis") and st.session_state.get("track_b_step", 0) >= 1:
        st.divider()
        st.subheader("Step 1.5. ë“±ì¥ì¸ë¬¼ ë° í™”ì ì •ë°€ ë¶„ì„")
        st.info("ğŸ—£ï¸ ë“±ì¥ì¸ë¬¼ì˜ ì„±ë³„, ë‚˜ì´, ë§íˆ¬ë¥¼ ì •ì˜í•˜ê³  ëª¨ë“  ëŒ€ì‚¬ì˜ ì£¼ì¸ì„ ì°¾ìŠµë‹ˆë‹¤. (TTS ë° ì˜ìƒ ì¼ê´€ì„±ìš©)")

        # 1. íŒŒì¼ ê²½ë¡œ ì„¤ì •
        char_file = paths["characters"]

        # 2. ì„¸ì…˜ ì´ˆê¸°í™” & ìë™ ë¶ˆëŸ¬ì˜¤ê¸°
        if "track_b_characters" not in st.session_state:
            if char_file.exists():
                try:
                    with open(char_file, "r", encoding="utf-8") as f:
                        st.session_state.track_b_characters = json.load(f)
                    st.toast("ğŸ“‚ ì €ì¥ëœ ìºë¦­í„° ë¶„ì„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.", icon="âœ…")
                except:
                    st.session_state.track_b_characters = None
            else:
                st.session_state.track_b_characters = None

        # 3. ë¶„ì„ ë²„íŠ¼ ìƒíƒœ ê²°ì •
        if st.session_state.track_b_characters is None:
            btn_label_15 = "ğŸ‘¥ ìºë¦­í„° ë° í™”ì ë¶„ì„ ì‹œì‘"
            btn_type_15 = "primary"
        else:
            btn_label_15 = "ğŸ”„ ë‹¤ì‹œ ë¶„ì„í•˜ê¸° (ë®ì–´ì“°ê¸°)"
            btn_type_15 = "secondary"

        # ë¶„ì„ ì‹¤í–‰ ë²„íŠ¼ ë¡œì§
        if st.button(btn_label_15, type=btn_type_15, key="btn_step15_character_analysis"):
            with st.spinner("ë“±ì¥ì¸ë¬¼ì„ ì‹ë³„í•˜ê³ , ì–´ìš¸ë¦¬ëŠ” ëª©ì†Œë¦¬(ì„±ìš°)ë¥¼ ë§¤ì¹­ ì¤‘ì…ë‹ˆë‹¤..."):
                try:
                    # 1) GPT ë¶„ì„ í•¨ìˆ˜ í˜¸ì¶œ (í”„ë¡¬í”„íŠ¸ê°€ voice_typeì„ í¬í•¨)
                    result_15 = analyze_characters_and_speakers(client, full_text)
                    
                    # 2) ë¶„ì„ ê²°ê³¼ì— ì„±ìš° ìë™ ë§¤ì¹­ (Mapping)
                    # GPTê°€ ì¤€ 'voice_type'ì„ UIìš© 'voice_label'ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
                    for char in result_15.get("characters", []):
                        # GPTê°€ ì œì•ˆí•œ íƒ€ì… (ì˜ˆ: adult_male_deep)
                        gpt_type = char.get("voice_type", "narrator")
                        
                        # UI í‘œì‹œìš© ë¼ë²¨ë¡œ ë³€í™˜ (ì˜ˆ: ğŸ‘¨ ì„±ì¸ ë‚¨ì„± (ì›íƒ...))
                        # ë§¤í•‘ë˜ì§€ ì•ŠëŠ” íƒ€ì…ì´ ì˜¤ë©´ ê¸°ë³¸ê°’ ì„¤ì •
                        ui_label = GPT_VOICE_TO_UI_LABEL.get(gpt_type, "--- ìë™/ê¸°ë³¸ê°’ ---")
                        
                        # ë°ì´í„°ì— ì €ì¥
                        char["voice_label"] = ui_label

                    # 3) íŒŒì¼ ì €ì¥
                    with open(char_file, "w", encoding="utf-8") as f:
                        json.dump(result_15, f, ensure_ascii=False, indent=4)
                    
                    st.session_state.track_b_characters = result_15
                    st.success("âœ… í™”ì ë¶„ì„ ë° ì„±ìš° ìºìŠ¤íŒ… ì™„ë£Œ!")
                    st.rerun()
                    
                except Exception as e:
                    st.error(f"ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

        # 4. ê²°ê³¼ í™•ì¸ ë° í¸ì§‘ (Data Editor)
        if st.session_state.track_b_characters:
            char_data = st.session_state.track_b_characters.get("characters", [])
            
            # [ì•ˆì „ì¥ì¹˜] ê¸°ì¡´ íŒŒì¼ì— 'voice_label' í•„ë“œê°€ ì—†ì„ ê²½ìš° ëŒ€ë¹„ (ê¸°ë³¸ê°’ ì±„ìš°ê¸°)
            for char in char_data:
                if "voice_label" not in char:
                    char["voice_label"] = "--- ìë™/ê¸°ë³¸ê°’ ---"
        
            st.markdown("#### ğŸ­ ë“±ì¥ì¸ë¬¼ í”„ë¡œí•„ & ì„±ìš° ì„¤ì •")
            st.caption("AIê°€ ì¶”ì²œí•œ ëª©ì†Œë¦¬ê°€ ë§ˆìŒì— ë“¤ì§€ ì•Šìœ¼ë©´, ì•„ë˜ **'ì§€ì • ëª©ì†Œë¦¬'** í•­ëª©ì„ í´ë¦­í•˜ì—¬ ë³€ê²½í•˜ì„¸ìš”.")

            # ë°ì´í„° ì—ë””í„° 
            edited_chars = st.data_editor(
                char_data,
                column_config={
                    "name": "ì´ë¦„ (ëŒ€í‘œ)",
                    "gender": st.column_config.SelectboxColumn("ì„±ë³„", options=["Male", "Female", "Unknown"], width="small"),
                    "age_group": st.column_config.SelectboxColumn("ì—°ë ¹ëŒ€", options=["Child", "Young","Adult", "Elder"], width="small"),
                    
                    # â˜… ëª©ì†Œë¦¬ ì„ íƒ 
                    "voice_label": st.column_config.SelectboxColumn(
                        "ğŸ™ï¸ ì§€ì • ëª©ì†Œë¦¬ (TTS)",
                        options=list(VOICE_PRESETS.keys()), # ìƒë‹¨ì— ì •ì˜í•œ í”„ë¦¬ì…‹ ëª©ë¡
                        width="medium",
                        required=True,
                        help="ì´ ìºë¦­í„°ì˜ ëŒ€ì‚¬ë¥¼ ì½ì„ ì„±ìš°ë¥¼ ì„ íƒí•˜ì„¸ìš”."
                    ),
                    
                    "tone": st.column_config.TextColumn("ë§íˆ¬/ì„±ê²©", width="medium"),
                    "visual": st.column_config.TextColumn("ì™¸ëª¨ ë¬˜ì‚¬", width="medium"),
                    "id": st.column_config.TextColumn("ID", disabled=True, width="small")
                },
                num_rows="dynamic",
                key="editor_chars_1_5"
            )

            st.divider()
            st.markdown("#### ğŸ’¬ ëŒ€ì‚¬ ë¶„ì„ ê²°ê³¼ (í™”ì & í˜ì´ì§€)")
            st.caption("ê° ëŒ€ì‚¬ê°€ **ëˆ„êµ¬ì˜ ë§**ì´ë©° **ëª‡ í˜ì´ì§€**ì— ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")

            # ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ í™•ì¸ (ê¸°ì¡´ ë™ì¼)
            dialogue_data = st.session_state.track_b_characters.get("dialogue_map", [])
            
            st.dataframe(
                dialogue_data, 
                column_config={
                    "quote": "ëŒ€ì‚¬ ë‚´ìš©",
                    "speaker_id": "í™”ì ID",
                    "page_num": st.column_config.NumberColumn("í˜ì´ì§€(Page)", format="%d"),
                    "context": "ìƒí™© ì„¤ëª…"
                },
                use_container_width=True
            )

            # ì €ì¥ ë° ë‹¤ìŒ ë‹¨ê³„ ë²„íŠ¼
            col_c1, col_c2 = st.columns([3, 1])
            with col_c1:
                st.caption("ìºë¦­í„° ì •ë³´ë¥¼ í™•ì •í•˜ê³  ì €ì¥í•©ë‹ˆë‹¤.")
            with col_c2:
                if st.button("âœ… ìºë¦­í„° í™•ì • (Step 2 ì´ë™)"):
                    # ìºë¦­í„° ì •ë³´ ì €ì¥
                    st.session_state.track_b_characters["characters"] = edited_chars
                    with open(char_file, "w", encoding="utf-8") as f:
                        json.dump(st.session_state.track_b_characters, f, ensure_ascii=False, indent=4)
                    
                    st.session_state.track_b_step = 2
                    st.rerun()

    # =========================================================
    # [Step 2] ì˜ˆê³ í¸ êµ¬ê°„ ì„ íƒ (Step 1ì´ ì™„ë£Œë˜ì–´ì•¼ í‘œì‹œ)
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 2:
        st.divider()
        st.subheader("Step 2. ì˜ˆê³ í¸ êµ¬ê°„(Highlight) ì„ íƒ")
        st.info("ğŸï¸ ì „ì²´ ì´ì•¼ê¸° ì¤‘, ì˜ˆê³ í¸ìœ¼ë¡œ ë§Œë“¤ì—ˆì„ ë•Œ ê°€ì¥ í¥ë¯¸ì§„ì§„í•œ ë¶€ë¶„ì„ ì„ íƒí•˜ì„¸ìš”.")
        segments_file =  paths["segments"]
        
        # ì„¸ì…˜ ì´ˆê¸°í™” & ìë™ ë¶ˆëŸ¬ì˜¤ê¸°
        if "track_b_segments" not in st.session_state:
            # ì €ì¥ëœ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸
            if segments_file.exists():
                try:
                    with open(segments_file, "r", encoding="utf-8") as f:
                        data = json.load(f)
                        st.session_state.track_b_segments = data.get("options", [])
                    st.toast("ğŸ“‚ ì €ì¥ëœ ì¶”ì²œ êµ¬ê°„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.", icon="âœ…")
                except:
                    st.session_state.track_b_segments = None
            else:
                st.session_state.track_b_segments = None

        if "selected_segment_index" not in st.session_state:
            st.session_state.selected_segment_index = 0 

        # êµ¬ê°„ ì¶”ì²œ ë²„íŠ¼ (ìƒíƒœì— ë”°ë¼ í…ìŠ¤íŠ¸ ë³€ê²½)
        if st.session_state.track_b_segments is None:
            btn_label = "ğŸ¬ AI ì˜ˆê³ í¸ êµ¬ê°„ ì¶”ì²œë°›ê¸° (3ê°€ì§€ ì˜µì…˜)"
            btn_type = "primary"
        else:
            btn_label = "ğŸ”„ ë‹¤ë¥¸ êµ¬ê°„ ì¶”ì²œë°›ê¸° (ë‹¤ì‹œ ë¶„ì„)"
            btn_type = "secondary"

        if st.button(btn_label, type=btn_type):
            if not st.session_state.track_b_analysis:
                st.error("Step 1 ë¶„ì„ì„ ë¨¼ì € ì™„ë£Œí•´ì£¼ì„¸ìš”.")
            else:
                with st.spinner("GPTê°€ í…ìŠ¤íŠ¸ë¥¼ í›‘ìœ¼ë©° ê°€ì¥ ì«„ê¹ƒí•œ êµ¬ê°„ì„ ì°¾ê³  ìˆìŠµë‹ˆë‹¤..."):
                    try:
                        # GPT í˜¸ì¶œ
                        segments_result = recommend_trailer_segments(
                            full_text, 
                            st.session_state.track_b_analysis
                        )
                        
                        # ê²°ê³¼ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥
                        with open(segments_file, "w", encoding="utf-8") as f:
                            json.dump(segments_result, f, ensure_ascii=False, indent=4)

                        st.session_state.track_b_segments = segments_result.get("options", [])
                        st.success("3ê°€ì§€ ì˜ˆê³ í¸ í›„ë³´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!")
                        st.rerun() # UI ê°±ì‹ ì„ ìœ„í•´ ë¦¬ëŸ°
                    except Exception as e:
                        st.error(f"êµ¬ê°„ ì¶”ì²œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

        # ì¶”ì²œ ê²°ê³¼ê°€ ìˆìœ¼ë©´ ì„ íƒ UI í‘œì‹œ
        if st.session_state.track_b_segments:
            options = st.session_state.track_b_segments
            
            # ë¼ë””ì˜¤ ë²„íŠ¼ì„ ìœ„í•œ ë¼ë²¨ ìƒì„±
            radio_options = [f"[{opt['type']}] {opt['title']}" for opt in options]
            
            selected_label = st.radio(
                "ì–´ë–¤ ìŠ¤íƒ€ì¼ì˜ ì˜ˆê³ í¸ì„ ë§Œë“œì‹œê² ìŠµë‹ˆê¹Œ?",
                radio_options,
                index=st.session_state.selected_segment_index
            )
            
            # ì„ íƒëœ ì˜µì…˜ì˜ ì¸ë±ìŠ¤ ì°¾ê¸°
            sel_idx = radio_options.index(selected_label)
            st.session_state.selected_segment_index = sel_idx 
            
            selected_data = options[sel_idx]

            # ì„ íƒëœ êµ¬ê°„ ìƒì„¸ ì •ë³´ ë³´ì—¬ì£¼ê¸°
            with st.container(border=True):
                st.markdown(f"### ğŸ‘‰ ì„ íƒëœ ì»¨ì…‰: {selected_data['title']}")
                st.caption(f"ğŸ’¡ ì¶”ì²œ ì´ìœ : {selected_data['reason']}")
                st.text_area(
                    "ğŸ“œ ì˜ˆê³ í¸ìœ¼ë¡œ ì“°ì¼ ì›ë¬¸ êµ¬ê°„ (ì´ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ëŒ€ë³¸ì´ ì‘ì„±ë©ë‹ˆë‹¤)", 
                    selected_data['target_text'], 
                    height=200
                )

            st.divider()
            
            # ë‹¤ìŒ ë‹¨ê³„(Step 3)ë¡œ ì´ë™ ë²„íŠ¼
            col_msg_2, col_btn_2 = st.columns([3, 1])
            with col_msg_2:
                st.caption("ì´ êµ¬ê°„ìœ¼ë¡œ í™•ì •í•˜ê³  ëŒ€ë³¸ì„ ì‘ì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
            with col_btn_2:
                if st.button("âœ… êµ¬ê°„ í™•ì • (Step 3 ëŒ€ë³¸ì‘ì„±)"):
                    st.session_state.track_b_step = 3
                    # ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì“¸ í…ìŠ¤íŠ¸ë¥¼ ì„¸ì…˜ì— ì €ì¥í•´ë‘¡ë‹ˆë‹¤.
                    st.session_state.target_trailer_text = selected_data['target_text']
                    st.toast("Step 3: ëŒ€ë³¸ ì‘ì„± ë‹¨ê³„ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                    st.rerun()

    # =========================================================
    # [Step 3] ì˜ˆê³ í¸ ëŒ€ë³¸ ì‘ì„± (ëª¨ë“œë³„ ê°œë³„ ì €ì¥/ê´€ë¦¬ ì ìš©)
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 3:
        st.divider()
        st.subheader("Step 3. ë§ì¶¤í˜• ì˜ˆê³ í¸ ëŒ€ë³¸ ì‘ì„±")
        st.info("ğŸ™ï¸ ì£¼ì¸ê³µ ì†Œê°œë¶€í„° ìœ„ê¸°ê¹Œì§€, í•œ í¸ì˜ ì˜í™” ì˜ˆê³ í¸ì²˜ëŸ¼ ì´ì•¼ê¸°ë¥¼ ì¬êµ¬ì„±í•©ë‹ˆë‹¤.")

        # 1. ì›”ë ¹ ì •ë³´ ë° ê¸°ë³¸ ì„¤ì •
        if "story_months" not in st.session_state:
            st.session_state.story_months = extract_age_from_filename(txt_file.name)
        
        months = st.session_state.story_months
        rec_info = get_recommendation_by_age(months)
        months_display = f"{months}ê°œì›”" if months > 0 else "ë¯¸ìƒ"

        # ìºë¦­í„° ì •ë³´ ë¡œë“œ
        char_info = st.session_state.get("track_b_characters", {})
        
        # í™”ì ì˜µì…˜ êµ¬ì„±
        base_speakers = ["narrator"]
        character_options = []
        if char_info and "characters" in char_info:
            for c in char_info["characters"]:
                character_options.append(f"{c['id']} ({c['name']}) {c['voice_type']}")
        
        all_speaker_options = base_speakers + character_options + ["child_male", "child_female","child_bright", "young_female","young_male","adult_female","adult_male","adult_male_deep","elder_female","elder_male","cute_animal","dog","fairy"]

        # ------------------------------------------------------------------
        # [UI] ê¸¸ì´ ë° ìŠ¤íƒ€ì¼ ì„ íƒ
        # ------------------------------------------------------------------
        st.markdown(f"**ëŒ€ìƒ ì—°ë ¹:** {months_display} ({rec_info['group']})")
        
        duration_options = ["Short (30~50ì´ˆ)", "Standard (1ë¶„~1ë¶„ 20ì´ˆ)", "Long (1ë¶„ 30ì´ˆ~1ë¶„ 50ì´ˆ)"]
        default_dur_idx = 1
        if rec_info["default_option"] == "Short": default_dur_idx = 0
        elif rec_info["default_option"] == "Long": default_dur_idx = 2

        selected_duration = st.radio(
            "â³ ì˜ìƒ ê¸¸ì´ë¥¼ ì„ íƒí•˜ì„¸ìš”:",
            duration_options,
            index=default_dur_idx,
            horizontal=True
        )
        duration_key = selected_duration.split()[0]

        st.write("ğŸ­ **ëŒ€ë³¸ êµ¬ì„± ìŠ¤íƒ€ì¼ ì„ íƒ:**")
        style_options = [
            "1ï¸âƒ£ ì¼ë°˜ ë²„ì „ (ë°¸ëŸ°ìŠ¤í˜•)", 
            "2ï¸âƒ£ ëŒ€í™”ë¬¸ ìœ„ì£¼ (ìºë¦­í„° ì—°ê¸° ì¤‘ì‹¬)", 
            "3ï¸âƒ£ ì¢…í•© êµ¬ì„± ëª¨ë“œ (ìš”ì•½ + í•˜ì´ë¼ì´íŠ¸)"
        ]
        
        style_selection = st.radio(
            "ìŠ¤íƒ€ì¼ì„ ì„ íƒí•˜ì„¸ìš”:",
            style_options,
            index=0,
            horizontal=True,
            label_visibility="collapsed",
            key="script_style_radio"
        )

        # ëª¨ë“œ ì‹ë³„ì(Key) ê²°ì •
        if "ëŒ€í™”ë¬¸" in style_selection:
            script_style_mode = "Conversation"
            st.info("ğŸ’¡ **ëŒ€í™”ë¬¸ ìœ„ì£¼:** ìºë¦­í„°ì˜ í‹°í‚¤íƒ€ì¹´ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ, ë‚˜ë ˆì´ì…˜ì„ ìµœì†Œí™”í•˜ì—¬ ëª°ì…ê°ì„ ë†’ì…ë‹ˆë‹¤.")
        elif "ì¢…í•© êµ¬ì„±" in style_selection:
            script_style_mode = "Comprehensive"
            st.info("ğŸ’¡ **ì¢…í•© êµ¬ì„± ëª¨ë“œ:** [ì´ˆë°˜ ìš”ì•½(30%)] + [í•µì‹¬ ì‚¬ê±´ ì§‘ì¤‘(70%)] êµ¬ì¡°ì…ë‹ˆë‹¤.")
        else:
            script_style_mode = "Standard"
            st.caption("ğŸ’¡ **ì¼ë°˜ ë²„ì „:** ì›ë¬¸ì˜ íë¦„ì„ ì ì ˆíˆ ìš”ì•½í•˜ê³  ë°œì·Œí•˜ì—¬ ê°€ì¥ ì•ˆì •ì ì¸ ì˜ˆê³ í¸ì„ ë§Œë“­ë‹ˆë‹¤.")
        
        st.session_state["script_style_mode"] = script_style_mode

        # ------------------------------------------------------------------
        # [í•µì‹¬ íŒŒíŠ¸] ëª¨ë“œë³„ í´ë” ê²½ë¡œ ì •ì˜ ë° ìƒì„±
        # ------------------------------------------------------------------
        safe_name = Path(txt_file.name).stem
        
        # ì˜ˆ: output/text/Standard/
        mode_dir = TEXT_OUT / script_style_mode
        
        # í´ë”ê°€ ì—†ìœ¼ë©´ ë¯¸ë¦¬ ìƒì„± (parents=True: ìƒìœ„í´ë” ì—†ìœ¼ë©´ ìƒì„±, exist_ok=True: ì´ë¯¸ ìˆì–´ë„ ì—ëŸ¬ ì•ˆ ëƒ„)
        mode_dir.mkdir(parents=True, exist_ok=True)
        
        # ------------------------------------------------------------------
        # [í•µì‹¬ ë¡œì§] í•´ë‹¹ í´ë” ë‚´ì—ì„œ ë²„ì „ ìŠ¤ìº”
        # ------------------------------------------------------------------
        # TEXT_OUT ëŒ€ì‹  mode_dirë¥¼ ë„˜ê²¨ì¤ë‹ˆë‹¤.
        sorted_versions, version_map = get_sorted_versions(mode_dir, safe_name, script_style_mode)
        
        selected_version = None
        current_file_path = None
        
        # [UI] ë²„ì „ ì„ íƒ (ì €ì¥ëœ íŒŒì¼ì´ ìˆì„ ê²½ìš°)
        if sorted_versions:
            col_ver, col_space = st.columns([1, 2])
            with col_ver:
                selected_version = st.selectbox(
                    f"ğŸ“‚ '{script_style_mode}' ì €ì¥ë³¸ ë¶ˆëŸ¬ì˜¤ê¸°:",
                    sorted_versions,
                    format_func=lambda x: f"Ver. {x} (ìµœì‹ )" if x == sorted_versions[0] else f"Ver. {x}",
                    key=f"version_selector_{script_style_mode}"
                )
                # â˜… í˜„ì¬ ì„ íƒëœ ëŒ€ë³¸ ë²„ì „ì„ ì„¸ì…˜ì— ì €ì¥
                st.session_state.current_script_ver = selected_version
            
            # ì„ íƒëœ íŒŒì¼ ê²½ë¡œ (ì´ë¯¸ mode_dir ì•ˆì— ìˆëŠ” íŒŒì¼ì„)
            current_file_path = version_map[selected_version]
            
            # ì„¸ì…˜ ë¡œë“œ ì²´í¬
            if st.session_state.get(f"loaded_path_{script_style_mode}") != current_file_path:
                try:
                    with open(current_file_path, "r", encoding="utf-8") as f:
                        data = json.load(f)
                        st.session_state.script_results[script_style_mode] = data
                        st.session_state[f"loaded_path_{script_style_mode}"] = current_file_path
                except Exception as e:
                    st.error(f"íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
        
        current_data = st.session_state["script_results"].get(script_style_mode)


        
        # ë‹¤ìŒ ë²„ì „ ë²ˆí˜¸ ê³„ì‚°
        next_ver = (sorted_versions[0] + 1) if sorted_versions else 1

        # ------------------------------------------------------------------
        # [UI] ëŒ€ë³¸ ìƒì„± ë²„íŠ¼
        # ------------------------------------------------------------------
        # í…ìŠ¤íŠ¸ ì¤€ë¹„
        raw_target_text = st.session_state.get("target_trailer_text", "")
        target_text = str(raw_target_text) if raw_target_text else ""
        
        if "full_text_cache" not in st.session_state:
            st.session_state.full_text_cache = txt_file.read_text(encoding="utf-8") if txt_file.exists() else ""
        full_text_content = st.session_state.full_text_cache

        btn_label = f"âœï¸ {script_style_mode} ëŒ€ë³¸ ì‘ì„±"
        # ë°ì´í„°ê°€ ìˆìœ¼ë©´ "ìƒˆ ë²„ì „ ìƒì„±", ì—†ìœ¼ë©´ "ëŒ€ë³¸ ì‘ì„±"
        if current_data:
            btn_label = f"âœ¨ ëŒ€ë³¸ ìƒˆë¡œ ìƒì„±í•˜ê¸° (Ver. {next_ver})"
            help_msg = "í˜„ì¬ ë‚´ìš©ì„ ìœ ì§€í•œ ì±„, ìƒˆë¡œìš´ ë²„ì „ì„ ì¶”ê°€ë¡œ ìƒì„±í•©ë‹ˆë‹¤."
        else:
            btn_label = f"âœï¸ {script_style_mode} ëŒ€ë³¸ ì‘ì„± (Ver. 1)"
            help_msg = "ì²« ë²ˆì§¸ ëŒ€ë³¸ì„ ìƒì„±í•©ë‹ˆë‹¤."

        if st.button(btn_label, type="primary", help=help_msg):
            if not target_text:
                st.error("Step 2ì—ì„œ êµ¬ê°„ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.")
            else:
                # ìŠ¤í¬ì¼ëŸ¬ ë°©ì§€ ë° ë°ì´í„° ì¤€ë¹„ (ê³µí†µ)
                page_map = st.session_state.get("page_map", {})
                spoiler_limit_page = find_spoiler_limit_page(target_text, page_map)
                safe_full_text = trim_full_text_by_page(full_text_content, spoiler_limit_page)
                safe_char_info = dict(char_info) if char_info else {}
                if safe_char_info and "dialogue_map" in safe_char_info:
                    safe_char_info["dialogue_map"] = trim_dialogue_map_by_page(safe_char_info["dialogue_map"], spoiler_limit_page)

                # AI ìƒì„± ì‹œì‘
                with st.spinner(f"AIê°€ '{script_style_mode}' ìŠ¤íƒ€ì¼ë¡œ ëŒ€ë³¸ì„ ì“°ê³  ìˆìŠµë‹ˆë‹¤..."):
                    try:
                        # ëª¨ë“œë³„ í•¨ìˆ˜ í˜¸ì¶œ
                        if script_style_mode == "Conversation":
                            result = generate_conversation_oriented_script(
                                target_text, duration_key, rec_info, safe_full_text, safe_char_info
                            )
                        elif script_style_mode == "Comprehensive":
                            analysis_data = st.session_state.get("track_b_analysis", {})
                            result = generate_comprehensive_script(
                                target_text, duration_key, rec_info, safe_full_text, safe_char_info, analysis_data
                            )
                        else: # Standard
                            result = generate_script_with_specs(
                                target_text, duration_key, rec_info, safe_full_text, safe_char_info
                            )

                        # ID -> í’€ë„¤ì„ ë³€í™˜ (ê³µí†µ í›„ì²˜ë¦¬)
                        if char_info and "characters" in char_info:
                            id_to_full = {c['id']: f"{c['id']} ({c['name']}) {c['voice_type']}" for c in char_info["characters"]}
                            for item in result.get("subtitles", []):
                                spk_id = item.get("speaker", "narrator")
                                if spk_id in id_to_full:
                                    item["speaker"] = id_to_full[spk_id]

                        # =========================================================
                        # [Step B] ëŒ€ì‚¬ ë‚´ ê´„í˜¸ ë° ì§€ë¬¸ ì œê±° (ë…ë¦½ ì‹¤í–‰)
                        # =========================================================
                        # ìë§‰ ë¦¬ìŠ¤íŠ¸ë¥¼ ë³„ë„ë¡œ ìˆœíšŒí•˜ë©° í…ìŠ¤íŠ¸ë§Œ ì •ì œ
                        for item in result.get("subtitles", []):
                            original_text = item.get("text", "")
                            
                            # ê´„í˜¸ê°€ í¬í•¨ëœ ê²½ìš°ì—ë§Œ ë¡œì§ ìˆ˜í–‰
                            if "(" in original_text and ")" in original_text:
                                # 1. ê´„í˜¸ì™€ ê·¸ ì•ˆì˜ ë‚´ìš© ì œê±°: (1ë‹¨ê³„), (ì§€ë¬¸) ë“±
                                clean_text = re.sub(r'\([^)]*\)', '', original_text)
                                
                                # 2. ê³µë°± ì •ë¦¬: ê´„í˜¸ ì‚­ì œë¡œ ìƒê¸´ ë‹¤ì¤‘ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì¶•ì†Œ
                                clean_text = re.sub(r'\s+', ' ', clean_text).strip()
                                
                                # 3. ì ìš©
                                item["text"] = clean_text
                        # =========================================================
                        # â˜…  ì”¬ ì••ì¶• ë¡œì§ (ê°™ì€ Page 3ê°œ ì´ìƒ -> 2ê°œ ì••ì¶•) â˜…
                        # =========================================================
                        # Scene No í• ë‹¹ ì „ì— ì••ì¶•ì„ ë¨¼ì € ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤.
                        result["subtitles"] = compress_consecutive_scenes(result["subtitles"])

                        # ---------------------------------------------------------
                        # â˜…  ì¥ë©´ ë²ˆí˜¸(Scene No) ìë™ ê·¸ë£¹í•‘ ì ìš© â˜…
                        # ---------------------------------------------------------
                        result["subtitles"] = assign_scene_numbers(result["subtitles"])
                        # ---------------------------------------------------------

                        # [ì €ì¥ ë¡œì§] ìƒˆ ë²„ì „ íŒŒì¼ ìƒì„± mode_dir ì•„ë˜ ì €ì¥
                        new_filename = f"script_{safe_name}_{script_style_mode}_v{next_ver}.json"
                        new_file_path = mode_dir / new_filename
                        
                        try:
                            with open(new_file_path, "w", encoding="utf-8") as f:
                                json.dump(result, f, ensure_ascii=False, indent=4)
                            
                            # ì„¸ì…˜ ê°±ì‹ 
                            st.session_state.script_results[script_style_mode] = result
                            st.session_state[f"loaded_path_{script_style_mode}"] = new_file_path
                            
                            st.toast(f"âœ… Ver. {next_ver} ìƒì„± ì™„ë£Œ!")
                            # Reruní•˜ë©´ sorted_versionsì˜ ë§¨ ì•ì— ìƒˆ ë²„ì „ì´ ì˜¤ë¯€ë¡œ, 
                            # Selectboxê°€ ìë™ìœ¼ë¡œ ìƒˆ ë²„ì „ì„ ê°€ë¦¬í‚¤ê²Œ ë¨.
                            st.rerun()
                            
                        except Exception as e:
                            st.error(f"ì €ì¥ ì¤‘ ì˜¤ë¥˜: {e}")
                        
                    except Exception as e:
                        st.error(f"ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
                # ìƒˆë¡œ ë§Œë“  ë²„ì „ì„ í˜„ì¬ ë²„ì „ìœ¼ë¡œ ì €ì¥ 
                st.session_state.current_script_ver = next_ver

        # ------------------------------------------------------------------
        # [UI] ê²°ê³¼ í™•ì¸ ë° ì—ë””í„° (Data Editor)
        # ------------------------------------------------------------------
        if current_data:
            st.divider()
            ver_label = selected_version if selected_version else next_ver - 1
            st.markdown(f"### ğŸ“ ëŒ€ë³¸ ì—ë””í„° (Ver. {ver_label})")
            st.caption(f"ğŸ’¡ AI ì½”ë©˜íŠ¸: {current_data.get('comment', '')}")

            subtitles = current_data.get("subtitles", [])
            
            # í™”ì ID ë§¤ì¹­ìš©
            id_to_option = {opt.split(" ")[0]: opt for opt in character_options}
            for item in subtitles:
                spk = item.get("speaker", "narrator")
                if spk in id_to_option:
                    item["speaker"] = id_to_option[spk]

            # ë°ì´í„° ì—ë””í„° (ëª¨ë“œë³„ë¡œ keyë¥¼ ë‹¤ë¥´ê²Œ ì£¼ì–´ ì¶©ëŒ ë°©ì§€)
            edited_subtitles = st.data_editor(
                subtitles,
                column_config={
                    # ì¥ë©´ ë²ˆí˜¸ ì»¬ëŸ¼  (ì‚¬ìš©ìê°€ ì§ì ‘ ìˆ˜ì •í•˜ì—¬ í•©ì¹˜ê±°ë‚˜ ë‚˜ëˆ„ê¸° ê°€ëŠ¥)
                    "scene_no": st.column_config.NumberColumn(
                        "ì¥ë©´# (Scene)", 
                        help="ê°™ì€ ë²ˆí˜¸ë¥¼ ê°€ì§„ ëŒ€ì‚¬ëŠ” í•˜ë‚˜ì˜ ê·¸ë¦¼/ì˜ìƒ ë°°ê²½ì„ ê³µìœ í•©ë‹ˆë‹¤.",
                        width="small",
                        step=1,
                        required=True
                    ),
                    "speaker": st.column_config.SelectboxColumn("í™”ì", options=all_speaker_options, width="medium", required=True),
                    "text": st.column_config.TextColumn("ëŒ€ì‚¬ (Subtitle)", width="large", required=True),
                    "source_page": st.column_config.NumberColumn("Page", width="small")
                },
                num_rows="dynamic",
                use_container_width=True,
                key=f"editor_{script_style_mode}_v{ver_label}"  # Key ì¤‘ìš”: ëª¨ë“œë³„ ë…ë¦½ì  ìƒíƒœ ìœ ì§€
            )

            # ê¸€ììˆ˜ ê³„ì‚°
            total_chars = sum(len(row["text"]) for row in edited_subtitles)
            est_time = total_chars / 6.6
            st.info(f"ğŸ“Š ê¸€ì ìˆ˜: **{total_chars}ì** (ì•½ {est_time:.1f}ì´ˆ)")

            # ------------------------------------------------------------------
            # [Step 4 ì´ë™] í™•ì • ë²„íŠ¼
            # ------------------------------------------------------------------
            col_msg, col_btn = st.columns([3, 1])
            with col_msg:
                st.caption(f"í˜„ì¬ ë³´ê³  ìˆëŠ” '{script_style_mode}' ëŒ€ë³¸ì„ ìµœì¢…ë³¸ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.")
            with col_btn:
                if st.button("âœ… í™•ì • ë° Step 4 ì´ë™"):
                    # 1. ì„¸ì…˜ ë°ì´í„° ì—…ë°ì´íŠ¸ (í¸ì§‘ë³¸ ë°˜ì˜)
                    current_data["subtitles"] = edited_subtitles
                    st.session_state.script_results[script_style_mode] = current_data
                    st.session_state.step1_scripts = edited_subtitles # ë‹¤ìŒ ë‹¨ê³„ìš©
                    
                    # 2. í˜„ì¬ íŒŒì¼ì— ë®ì–´ì“°ê¸° (ìƒˆ ë²„ì „ ìƒì„± X)
                    if current_file_path:
                        with open(current_file_path, "w", encoding="utf-8") as f:
                            json.dump(current_data, f, ensure_ascii=False, indent=4)
                    
                    st.session_state.track_b_step = 4
                    st.toast("ëŒ€ë³¸ì´ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    st.rerun()
    # =========================================================
    # [Step 4] TTS ìƒì„± ë° ì „ì²´ ë¯¸ë¦¬ë“£ê¸°
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 4:
        st.divider()
        st.subheader("Step 4. TTS ìŒì„± ìƒì„± ë° í™•ì¸")
        
        # 1. í˜„ì¬ ëŒ€ë³¸ ì •ë³´ í™•ì¸
        # Step 3ì—ì„œ ë„˜ì–´ì˜¨ script_verê°€ ì—†ìœ¼ë©´ 1ë¡œ ê°€ì • (í˜¹ì€ ì—ëŸ¬ ì²˜ë¦¬)
        current_script_ver = st.session_state.get("current_script_ver", 1)
        current_mode = st.session_state.get("script_style_mode", "Standard")
        
        st.info(f"ğŸ§ í˜„ì¬ **ëŒ€ë³¸ Ver. {current_script_ver} ({current_mode})**ì„ ê¸°ë°˜ìœ¼ë¡œ ì‘ì—…ì„ ì§„í–‰í•©ë‹ˆë‹¤.")

        # 2. ê²½ë¡œ ì„¤ì •
        story_dir_name = txt_file.stem
        # outputs / ë™í™”ì´ë¦„ / tts / ëª¨ë“œëª…
        TTS_MODE_BASE_DIR = Path("outputs") / story_dir_name / "tts" / current_mode
        TTS_MODE_BASE_DIR.mkdir(parents=True, exist_ok=True)

        # ------------------------------------------------------------------
        # [Logic] ê¸°ì¡´ ë²„ì „ ìŠ¤ìº” (v{s}_{a}_{model} ëŒ€ì‘)
        # ------------------------------------------------------------------
        # í´ë”ëª…ì„ ë¶„ì„í•˜ì—¬ (script_ver, audio_ver) -> path ë§¤í•‘
        # ë’¤ì— ëª¨ë¸ëª…ì´ ë¶™ì–´ë„ ì•ì˜ ìˆ«ìë§Œ íŒŒì‹±í•˜ì—¬ ë²„ì „ì„ ê´€ë¦¬í•¨
        sorted_keys, path_map = get_tts_versions_v2(TTS_MODE_BASE_DIR)
        dir_list = [d for d in TTS_MODE_BASE_DIR.iterdir() if d.is_dir() and d.name.startswith("v")]
        
        version_map = {}  # key: (s_ver, a_ver), value: {path, model_name}
        
        for d in dir_list:
            try:
                # ì˜ˆ: v1_1_clova -> parts=["v1", "1", "clova"]
                # ì˜ˆ: v1_2       -> parts=["v1", "2"]
                parts = d.name.split("_")
                if len(parts) >= 2:
                    s_ver = int(parts[0].replace("v", "")) # v1 -> 1
                    a_ver = int(parts[1])                  # 1
                    
                    # ëª¨ë¸ëª… ì¶”ì¶œ (3ë²ˆì§¸ ìš”ì†Œë¶€í„° ëê¹Œì§€, í˜¹ì€ ì—†ìœ¼ë©´ "Unknown")
                    model_suffix = "_".join(parts[2:]) if len(parts) > 2 else ""
                    
                    # (s, a) í‚¤ê°€ ì¤‘ë³µë  ì¼ì€ ì‹œìŠ¤í…œìƒ ì—†ë‹¤ê³  ê°€ì • (ìˆìœ¼ë©´ ë®ì–´ì”€)
                    version_map[(s_ver, a_ver)] = {
                        "path": d,
                        "model": model_suffix,
                        "full_name": d.name
                    }
            except Exception:
                continue # íŒŒì‹± ì‹¤íŒ¨í•œ í´ë”ëŠ” ë¬´ì‹œ

        # í‚¤ ì •ë ¬ (ìµœì‹  ë²„ì „ì´ ìœ„ë¡œ ì˜¤ë„ë¡ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬)
        sorted_keys = sorted(version_map.keys(), reverse=True)
        
        selected_key = None
        
        # [UI] ë¶ˆëŸ¬ì˜¤ê¸° Selectbox
        if sorted_keys:
            col_sel, col_sp = st.columns([1, 2])
            with col_sel:
                def format_func(key):
                    s, a = key
                    # version_mapì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                    info = version_map[key]
                    model_display = f" [{info['model']}]" if info['model'] else ""
                    
                    is_latest = (key == sorted_keys[0])
                    return f"ğŸ“œv{s} â” ğŸ§v{a}{model_display}" + (" (ìµœì‹ )" if is_latest else "")

                selected_key = st.selectbox(
                    f"ğŸ“‚ '{current_mode}' TTS ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°:",
                    sorted_keys,
                    format_func=format_func,
                    key=f"tts_sel_{current_mode}"
                )
                if selected_key:
                    s_ver, a_ver = selected_key
                    st.session_state.current_audio_ver = a_ver # í˜„ì¬ ì˜¤ë””ì˜¤ ë²„ì „ì´ ì–´ë””ì¸ì§€ ì „ë‹¬
            
                # ì„ íƒëœ í´ë” ë¡œë“œ ë¡œì§
                # path_map ëŒ€ì‹  version_mapì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
                if selected_key:
                    # version_map êµ¬ì¡°: {'path': Pathê°ì²´, 'model': ë¬¸ìì—´, 'full_name': ë¬¸ìì—´}
                    target_info = version_map[selected_key]
                    target_dir = target_info["path"]  # ì—¬ê¸°ì„œ ê²½ë¡œ ì¶”ì¶œ
                    
                    # ì„¸ì…˜ ê°±ì‹  (ê²½ë¡œê°€ ë‹¬ë¼ì¡Œì„ ë•Œë§Œ)
                    if st.session_state.get(f"loaded_tts_dir_{current_mode}") != str(target_dir):
                        try:
                            with open(target_dir / "manifest.json", "r", encoding="utf-8") as f:
                                data = json.load(f)
                            
                            st.session_state.track_b_audio = data.get("audio_data", [])
                            st.session_state.track_b_full_audio = data.get("full_audio_path", "")
                            st.session_state.step1_scripts = data.get("scripts", [])
                            
                            st.session_state[f"loaded_tts_dir_{current_mode}"] = str(target_dir)
                        except Exception as e:
                            st.error(f"ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

        # ------------------------------------------------------------------
        # [Logic] ë‹¤ìŒ ì˜¤ë””ì˜¤ ë²„ì „(Next Audio Ver) ê³„ì‚°
        # ------------------------------------------------------------------
        # í˜„ì¬ ëŒ€ë³¸ ë²„ì „(s)ê³¼ ì¼ì¹˜í•˜ëŠ” í‚¤ë“¤ ì¤‘ì—ì„œ ì˜¤ë””ì˜¤ ë²„ì „(a)ì˜ ìµœëŒ“ê°’ ì°¾ê¸°
        existing_audio_vers = [k[1] for k in sorted_keys if k[0] == current_script_ver]
        
        # ëª¨ë¸ëª…ê³¼ ìƒê´€ì—†ì´ ìˆ«ìë§Œ ë³´ê³  +1 (ì˜ˆ: v1_1_clovaê°€ ìˆì–´ë„ ë‹¤ìŒì€ v1_2_gptê°€ ë¨)
        next_audio_ver = (max(existing_audio_vers) + 1) if existing_audio_vers else 1
        
        # í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ë°ì´í„°
        current_audio_data = st.session_state.get("track_b_audio", [])
        current_full_audio = st.session_state.get("track_b_full_audio", "")

        # ------------------------------------------------------------------
        # [UI] ìƒì„± ë²„íŠ¼
        # ------------------------------------------------------------------
        st.markdown("#### ğŸ› ï¸ ìŒì„± ìƒì„± ì„¤ì •")
    
        col_eng, col_opt = st.columns(2)
        
        with col_eng:
            # TTS ëª¨ë¸ ì„ íƒ
            tts_engine_choice = st.radio(
                "ì‚¬ìš©í•  TTS ëª¨ë¸ ì„ íƒ",
                options=["Naver Clova", "GPT-4o Mini TTS", "Gemini 2.5 Flash TTS", "Gemini 2.5 Pro TTS"],
                index=0
            )
            
            # ì‹¤ì œ í•¨ìˆ˜ì— ë„˜ê¸¸ engine string ë³€í™˜
            if tts_engine_choice == "Naver Clova":
                selected_engine = "clova"
            elif tts_engine_choice == "GPT-4o Mini TTS":
                selected_engine = "gpt" # í˜¹ì€ í•¨ìˆ˜ ë‚´ë¶€ êµ¬í˜„ì— ë”°ë¼ 'gpt-4o-mini' ë“±
            elif tts_engine_choice == "Gemini 2.5 Flash TTS":
                selected_engine = "gemini-flash"
            else: # Gemini 2.5 PRO TTS
                selected_engine = "gemini-pro"

        with col_opt:
            # 1. í™”ì ì„¤ì • UI (ì¡°ê±´ë¶€ í™œì„±í™”)
            # Clovaê°€ ì•„ë‹Œ ê²½ìš°(GPT/Gemini)ì—ë§Œ ë³€ê²½ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
            is_premium_engine = "Clova" not in tts_engine_choice
            
            st.write("ğŸ—£ï¸ í™”ì êµ¬ì„± ì„¤ì •")
            speaker_mode = st.selectbox(
                "ëª©ì†Œë¦¬ êµ¬ì„±", 
                ["ë‹¤ìˆ˜ í™”ì (ìë™ ë°°ì •)", "ë‹¨ì¼ í™”ì (Narrator Only)"],
                index=0, # ê¸°ë³¸ê°’: ë‹¤ìˆ˜ í™”ì
                disabled=not is_premium_engine, # Clovaë©´ ì„ íƒ ë¶ˆê°€ëŠ¥í•˜ê²Œ ì ê¸ˆ
                help="GPT/Gemini ëª¨ë¸ ì‚¬ìš© ì‹œ ë‹¨ì¼ í™”ì(ë‚˜ë ˆì´ì…˜ ì „ìš©) ëª¨ë“œë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
            )
            
            # Clova ì„ íƒ ì‹œ ì•ˆë‚´ ë¬¸êµ¬
            if not is_premium_engine:
                st.caption("ğŸ”’ Naver ClovaëŠ” ìŠ¤í¬ë¦½íŠ¸ì˜ í™”ì ì„¤ì •ì„ ë”°ë¦…ë‹ˆë‹¤.")
            # 2. ìŒì„± ì†ë„ ì¡°ì ˆ ìŠ¬ë¼ì´ë”
            st.write("ğŸ‘¶ ëŒ€ìƒ ì—°ë ¹ ë° ì†ë„ ì„¤ì •")    
            # 1. ëŒ€ìƒ ì—°ë ¹ëŒ€ ì„ íƒ (ì‚¬ì „ ì„¤ì •)
            age_category = st.radio(
                "ëŒ€ìƒ ì—°ë ¹ëŒ€ ì„ íƒ",
                ["ë¯¸ì·¨í•™ (48~72ê°œì›”)", "ì´ˆë“± ì €í•™ë…„ (73~96ê°œì›”)", "ì´ˆë“± ê³ í•™ë…„ (96ê°œì›”+)", "ì§ì ‘ ì„¤ì •"],
                horizontal=True,
                help="ì—°ë ¹ëŒ€ì— ë§ì¶° ìµœì ì˜ ì†ë„ê°€ ê¸°ë³¸ ì œê³µë©ë‹ˆë‹¤."
            )

            # 2. ì—°ë ¹ëŒ€ë³„ ê¸°ë³¸ê°’ ë§¤í•‘
            if age_category == "ë¯¸ì·¨í•™ (48~72ê°œì›”)":
                default_speed = 0.8  # ì²œì²œíˆ ì½ì–´ì¤Œ
            elif age_category == "ì´ˆë“± ì €í•™ë…„ (73~96ê°œì›”)":
                default_speed = 1.0  # í‘œì¤€ ì†ë„
            elif age_category == "ì´ˆë“± ê³ í•™ë…„ (96ê°œì›”+)":
                default_speed = 1.2  # ì¡°ê¸ˆ ë¹ ë¥¸ ìˆí¼ ìŠ¤íƒ€ì¼
            else:
                default_speed = 1.0

            # 3. ì„¸ë°€í•œ ì¡°ì •ì„ ìœ„í•œ í•˜ë‹¨ ë°” (Slider)
            # ì—°ë ¹ëŒ€ë¥¼ ì„ íƒí•˜ë©´ ì´ ë°”ì˜ ìœ„ì¹˜ê°€ ìë™ìœ¼ë¡œ ì›€ì§ì…ë‹ˆë‹¤.
            voice_speed = st.slider(
                "ìŒì„± ì†ë„ ë¯¸ì„¸ ì¡°ì ˆ",
                min_value=0.5,
                max_value=1.5,
                value=default_speed, # ìœ„ì—ì„œ ì •í•´ì§„ ê°’ì´ ì´ˆê¸°ê°’ìœ¼ë¡œ ë“¤ì–´ê°
                step=0.1,
                help="ì—°ë ¹ëŒ€ ì„ íƒ í›„ì—ë„ ì—¬ê¸°ì„œ ì„¸ë°€í•˜ê²Œ ì†ë„ë¥¼ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤."
            )
            
            st.caption(f"í˜„ì¬ ì„¤ì •ëœ ì†ë„: **{voice_speed}x**")

        st.write("") # ê°„ê²©
        # ------------------------------------------------------------------
        # ìƒì„± ì „ í”„ë¡¬í”„íŠ¸ & ë°ì´í„° ë§¤í•‘ ë¯¸ë¦¬ë³´ê¸° (Preview)
        # ------------------------------------------------------------------
        st.markdown("#### ğŸ‘ï¸ ìƒì„± ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°")
        with st.expander("ğŸ” í™”ì ë° ìŠ¤íƒ€ì¼ í”„ë¡¬í”„íŠ¸ êµ¬ì„± í™•ì¸í•˜ê¸° (í´ë¦­)", expanded=False):
            # 1. ë°ì´í„° ì¤€ë¹„
            preview_scripts = st.session_state.get("step1_scripts", [])
            char_info_p = st.session_state.get("track_b_characters", {})
            chars_data_p = char_info_p.get("characters", [])
            dial_map_p = char_info_p.get("dialogue_map", [])

            # ë§¤í•‘ í…Œì´ë¸” (Toneìš©)
            char_tone_map_p = {c['id']: c.get('tone', '') for c in chars_data_p}

            preview_data = []

            for idx, script in enumerate(preview_scripts):
                text = script["text"]
                raw_speaker = script["speaker"] # "char_01 (í¥ë¶€)..."
                page_num = int(script.get("source_page", 0)) # ëŒ€ë³¸ì˜ í˜ì´ì§€ ë²ˆí˜¸
                
                # ID ì¶”ì¶œ
                speaker_id = raw_speaker.split(" ")[0] if raw_speaker else "narrator"
                
                # API Inputìš© í™”ì ê²°ì •
                final_api_speaker = speaker_id
                if speaker_mode == "ë‹¨ì¼ í™”ì (Narrator Only)":
                    final_api_speaker = "narrator (Override)"

                generated_prompt = ""
                
                if "narrator" in speaker_id.lower():
                    generated_prompt = "(ê¸°ë³¸ ë‚˜ë ˆì´ì…˜ í†¤) Calm and clear storytelling."
                else:
                    c_tone = char_tone_map_p.get(speaker_id, "Normal tone")
                    
                    # êµ¬ì¡°ì  ê²€ìƒ‰ í•¨ìˆ˜ í˜¸ì¶œ (í™”ì, í˜ì´ì§€, í…ìŠ¤íŠ¸ ëª¨ë‘ ë„˜ê¹€)
                    c_ctx = find_context_by_structure(text, raw_speaker, page_num, dial_map_p)
                    
                    if c_ctx:
                        generated_prompt = f"Tone: {c_tone} / Situation: {c_ctx}"
                    else:
                        generated_prompt = f"Tone: {c_tone} (Context Not Found)"

                preview_data.append({
                    "No": idx + 1,
                    "í™”ì (API Input)": final_api_speaker,
                    "ì›ë³¸ ID": speaker_id,
                    "ëŒ€ì‚¬ ë‚´ìš© (Text)": text,
                    "ìƒì„±ëœ í”„ë¡¬í”„íŠ¸ (Style Prompt)": generated_prompt
                })

            # 2. DataFrameìœ¼ë¡œ í‘œì‹œ
            if preview_data:
                st.dataframe(
                    preview_data,
                    column_config={
                        "No": st.column_config.NumberColumn(width="small"),
                        "í™”ì (API Input)": st.column_config.TextColumn(width="medium"),
                        "ì›ë³¸ ID": st.column_config.TextColumn(width="small"),
                        "ëŒ€ì‚¬ ë‚´ìš© (Text)": st.column_config.TextColumn(width="large"),
                        "ìƒì„±ëœ í”„ë¡¬í”„íŠ¸ (Style Prompt)": st.column_config.TextColumn(
                            "AIì—ê²Œ ì „ë‹¬ë  ì§€ì‹œë¬¸ (Prompt)", 
                            width="large",
                            help="ì´ ë‚´ìš©ì´ Gemini/GPTì—ê²Œ ì „ë‹¬ë˜ì–´ ì—°ê¸° í†¤ì„ ê²°ì •í•©ë‹ˆë‹¤."
                        ),
                    },
                    use_container_width=True,
                    hide_index=True
                )
            else:
                st.warning("í‘œì‹œí•  ëŒ€ë³¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")

        st.write("") # ì—¬ë°±
        
        # ... (ì´ ë°‘ì— ê¸°ì¡´ 'btn_label =' ë° 'if st.button...' ì½”ë“œê°€ ì´ì–´ì§‘ë‹ˆë‹¤) ...
        # ë²„íŠ¼ ë¼ë²¨: "ëŒ€ë³¸ v2 ê¸°ë°˜ ìŒì„± v3 ìƒì„±"
        btn_label = f"ğŸ™ï¸ ìŒì„± ìƒì„±í•˜ê¸° (Script v{current_script_ver} â” Audio v{next_audio_ver})"
        
        if st.button(btn_label, type="primary"):
            final_scripts = st.session_state.get("step1_scripts", [])
            
            if not final_scripts:
                st.error("ìƒì„±í•  ëŒ€ë³¸ì´ ì—†ìŠµë‹ˆë‹¤.")
            else:
                with st.spinner(f"ìŒì„± ìƒì„± ì¤‘... (Model: {selected_engine})"):
                    try:
                        # í´ë”ëª…: v{ëŒ€ë³¸}_{ìŒì„±}_{ëª¨ë¸ëª…} í˜•íƒœë¡œ í›„ì²˜ë¦¬ ì €ì¥ (ì‹ë³„ ìš©ì´)
                        # ëª¨ë¸ëª… íŒŒì¼ì‹œìŠ¤í…œ ì•ˆì „í•˜ê²Œ ë³€í™˜
                        safe_model_name = selected_engine.replace(" ", "_")
                        folder_name = f"v{current_script_ver}_{next_audio_ver}_{safe_model_name}"
                        
                        new_ver_dir = TTS_MODE_BASE_DIR / folder_name
                        segments_dir = new_ver_dir / "segments"
                        
                        new_ver_dir.mkdir(parents=True, exist_ok=True)
                        segments_dir.mkdir(parents=True, exist_ok=True)
                        
                        uid = uuid.uuid4().hex[:6]

                        # =============================================================
                        # ìŠ¤íƒ€ì¼ í”„ë¡¬í”„íŠ¸(Style Prompt) ë™ì  ìƒì„± ë¡œì§
                        # =============================================================
                        
                        # 1. ë°ì´í„° ë¡œë“œ (Step 1.5 ê²°ê³¼ë¬¼)
                        char_info = st.session_state.get("track_b_characters", {})
                        characters_data = char_info.get("characters", [])
                        dialogue_map_data = char_info.get("dialogue_map", [])

                        # 2. ê²€ìƒ‰ìš© ë§¤í•‘(Lookup) í…Œì´ë¸” ìƒì„±
                        # (1) ìºë¦­í„° ID -> Tone ë§¤í•‘
                        # ì˜ˆ: {'char_01': 'ì†Œì‹¬í•˜ê³  ê²ì´ ë§ì€ ë§íˆ¬', ...}
                        char_tone_map = {c['id']: c.get('tone', '') for c in characters_data}
                        
                        # (2) ëŒ€ì‚¬ ë‚´ìš© -> Context ë§¤í•‘
                        # ëŒ€ë³¸ ìˆ˜ì • ê³¼ì •ì—ì„œ í…ìŠ¤íŠ¸ê°€ ì•½ê°„ ë°”ë€” ìˆ˜ ìˆìœ¼ë¯€ë¡œ, 
                        # ì™„ë²½í•œ ë§¤ì¹­ì´ ì•ˆ ë  ìˆ˜ ìˆìŒì„ ê°ì•ˆí•´ì•¼ í•©ë‹ˆë‹¤. (ì—¬ê¸°ì„œëŠ” ì •í™•í•œ í…ìŠ¤íŠ¸ ë§¤ì¹­ ì‹œë„)
                        dialogue_context_map = {d['quote'].strip(): d.get('context', '') for d in dialogue_map_data}

                        # 3. ìŠ¤í¬ë¦½íŠ¸ ìˆœíšŒí•˜ë©° í”„ë¡¬í”„íŠ¸ ë¦¬ìŠ¤íŠ¸ ìƒì„±
                        style_prompts_list = []
                        
                        # í™”ì ì •ë³´ ë³´ì •ì„ ìœ„í•œ ì„ì‹œ ë¦¬ìŠ¤íŠ¸
                        processed_speakers = [] 

                        for script in final_scripts:
                            text = script["text"]
                            # speaker í•„ë“œì— ì´ë¦„ì´ ì„ì—¬ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ IDë§Œ ì¶”ì¶œ (ì˜ˆ: "char_01 (í¥ë¶€)..." -> "char_01")
                            raw_speaker = script["speaker"]
                            speaker_id = raw_speaker.split(" ")[0] if raw_speaker else "narrator"
                            
                            # (A) ë‚˜ë ˆì´í„° ì²˜ë¦¬
                            if "narrator" in speaker_id.lower() or speaker_id == "narrator":
                                if speaker_mode == "ë‹¨ì¼ í™”ì (Narrator Only)":
                                    # ë‹¨ì¼ í™”ì ëª¨ë“œë©´ ë‚˜ë ˆì´ì…˜ë„ ìƒí™©ì— ë”°ë¼ í†¤ì´ ë°”ë€Œë©´ ì¢‹ê² ì§€ë§Œ, ê¸°ë³¸ì€ ì°¨ë¶„í•˜ê²Œ
                                    current_prompt = "ì°¨ë¶„í•˜ê³  ëª°ì…ê° ìˆëŠ” ë™í™” êµ¬ì—°ì¡°ë¡œ ì½ì–´ì£¼ì„¸ìš”."
                                else:
                                    current_prompt = "ì°¨ë¶„í•˜ê³  ëª…í™•í•œ ë°œìŒì˜ ë‚˜ë ˆì´ì…˜ í†¤."
                                processed_speakers.append("narrator") # ë‹¨ì¼í™”ì ëª¨ë“œ ì²˜ë¦¬ëŠ” ì•„ë˜ì—ì„œ ë®ì–´ì”Œì›Œì§

                            # (B) ìºë¦­í„° ì²˜ë¦¬
                            else:
                                # 1. ì„±ê²©/ë§íˆ¬(Tone) ê°€ì ¸ì˜¤ê¸°
                                char_tone = char_tone_map.get(speaker_id, "ì¼ë°˜ì ì¸ ëª©ì†Œë¦¬")
                                
                                # 2. ìƒí™©(Context) ê°€ì ¸ì˜¤ê¸°
                                # í…ìŠ¤íŠ¸ ì•ë’¤ ê³µë°± ì œê±° í›„ ë§¤ì¹­ ì‹œë„
                                script_context = find_context_by_structure(text, raw_speaker, page_num, dialogue_map_data)
                                
                                # 3. í”„ë¡¬í”„íŠ¸ ì¡°í•© (Gemini/GPTìš©)
                                # ì˜ì–´ë¡œ ë³€í™˜í•´ì„œ ë„˜ê¸°ë©´ ë” ì¢‹ì§€ë§Œ, í•œê¸€ë¡œë„ ìµœì‹  ëª¨ë¸ì€ ì˜ ì´í•´í•©ë‹ˆë‹¤.
                                # í¬ë§·: [Role/Tone] + [Context/Situation]
                                if script_context:
                                    # ì˜ˆ: "Roleplay with a 'ì†Œì‹¬í•œ ëª©ì†Œë¦¬' tone. The situation is 'í˜¸ë‘ì´ë¥¼ í”¼í•´ ë„ë§ì¹¨'. Speak..."
                                    current_prompt = (
                                        f"Roleplay with a '{char_tone}' tone. "
                                        f"The situation is '{script_context}'. "
                                        f"Speak the following Korean text with the appropriate emotion."
                                    )
                                else:
                                    current_prompt = (
                                        f"Roleplay with a '{char_tone}' tone. "
                                        f"Speak the following Korean text naturally."
                                    )
                                
                                processed_speakers.append(speaker_id)

                            style_prompts_list.append(current_prompt)
                        
                        # 1. í…ìŠ¤íŠ¸ì™€ í™”ì ë¦¬ìŠ¤íŠ¸ ì¶”ì¶œ (ê¸°ë³¸ê°’)
                        texts = [s["text"] for s in final_scripts]
                        original_speakers = [s["speaker"] for s in final_scripts] # ì›ë³¸ ë³´ì¡´
                        
                        #  ë‹¨ì¼ í™”ì ëª¨ë“œì¼ ê²½ìš°, ëª¨ë“  í™”ìë¥¼ 'narrator'ë¡œ ê°•ì œ ë³€ê²½
                        if speaker_mode == "ë‹¨ì¼ í™”ì (Narrator Only)":
                            # ë¦¬ìŠ¤íŠ¸ ì „ì²´ë¥¼ 'narrator'ë¡œ ì±„ì›€
                            speakers = ["narrator"] * len(texts)
                            print(f"â„¹ï¸ [Info] ë‹¨ì¼ í™”ì ëª¨ë“œ ì ìš©: ëª¨ë“  í™”ìë¥¼ narratorë¡œ ì„¤ì •í•¨.")
                        else:
                            # ë‹¤ìˆ˜ í™”ì ëª¨ë“œë¼ë©´ ì›ë³¸ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                            speakers = original_speakers

                        #  1. ë°°ìˆ˜(Float)ë¥¼ Clova ê¸°ì¤€ ì •ìˆ˜(Int)ë¡œ ë³€í™˜
                        # ê³µì‹: (1.0 - ë°°ìˆ˜) * 10 
                        # ì˜ˆ: 1.2ë°° -> -2 (ë¹ ë¦„), 0.8ë°° -> 2 (ëŠë¦¼)
                        clova_speed_int = int((1.0 - voice_speed) * 10)
                        
                        # ë²”ìœ„ë¥¼ -5 ~ 5 ë¡œ ì•ˆì „í•˜ê²Œ ì œí•œ (Clova API í—ˆìš©ë²”ìœ„ ì¤€ìˆ˜)
                        clova_speed_int = max(-5, min(5, clova_speed_int))
                        
                        # ì—¬ê¸°ì„œ engine ì¸ì ì „ë‹¬
                        audio_paths = generate_audio_for_subtitles(
                            subtitles=texts,
                            output_dir=segments_dir,
                            uid=uid,
                            speakers=speakers,
                            engine=selected_engine,  # <--- ì„ íƒí•œ ì—”ì§„ ì „ë‹¬
                            parallel=True ,
                            global_speed=clova_speed_int,
                            style_prompts=style_prompts_list
                        )
                        
                        # 2. ë°ì´í„° êµ¬ì„±
                        audio_data_list = []
                        valid_paths = []
                        for idx, path in enumerate(audio_paths):
                            script_item = final_scripts[idx]
                            if path and Path(path).exists():
                                dur = get_audio_duration(str(path))
                                audio_data_list.append({
                                    "text": script_item["text"],
                                    "speaker": script_item["speaker"],
                                    "path": str(path),
                                    "duration": dur,
                                    "scene_no": script_item.get("scene_no")
                                })
                                valid_paths.append(path)
                            else:
                                audio_data_list.append({
                                    "text": script_item["text"],
                                    "speaker": script_item["speaker"],
                                    "path": None,  # ê²½ë¡œëŠ” ì—†ìŒ
                                    "duration": 0,
                                    "scene_no": script_item.get("scene_no"),
                                    "status": "failed" # ì‹¤íŒ¨í–ˆìŒì„ í‘œì‹œ
                                })
                                
                                # (ì„ íƒ) ë””ë²„ê¹…ì„ ìœ„í•´ ì‹¤íŒ¨ ë¡œê·¸ ì¶œë ¥
                                print(f"âš ï¸ ì˜¤ë””ì˜¤ ìƒì„± ì‹¤íŒ¨: {script_item['text'][:10]}...")

                        # 3. Full Audio ë³‘í•©
                        full_audio_str = ""
                        if valid_paths:
                            full_path = new_ver_dir / f"full_{folder_name}.mp3"
                            if merge_audio_files(valid_paths, str(full_path)):
                                full_audio_str = str(full_path)
                        
                        # 4. Manifest ì €ì¥
                        manifest = {
                            "script_ver": current_script_ver,
                            "audio_ver": next_audio_ver,
                            "mode": current_mode,
                            "engine": selected_engine,
                            "created_at": str(datetime.now()),
                            "scripts": final_scripts,
                            "audio_data": audio_data_list,
                            "full_audio_path": full_audio_str
                        }
                        # [Debug] ì–´ë””ì— setì´ ìˆëŠ”ì§€ ë²”ì¸ ì°¾ê¸°
                        def find_set_in_dict(d, path="root"):
                            if isinstance(d, set):
                                st.error(f"ğŸš¨ ë²”ì¸ ë°œê²¬! ê²½ë¡œ: {path} / ê°’: {d}")
                            elif isinstance(d, dict):
                                for k, v in d.items():
                                    find_set_in_dict(v, f"{path}.{k}")
                            elif isinstance(d, list):
                                for i, v in enumerate(d):
                                    find_set_in_dict(v, f"{path}[{i}]")
                        
                        find_set_in_dict(manifest)
                        with open(new_ver_dir / "manifest.json", "w", encoding="utf-8") as f:
                            json.dump(manifest, f, ensure_ascii=False, indent=4)
                            
                        # 5. ì„¸ì…˜ ê°±ì‹  ë° ë¦¬ëŸ°
                        st.session_state.track_b_audio = audio_data_list
                        st.session_state.track_b_full_audio = full_audio_str
                        st.session_state[f"loaded_tts_dir_{current_mode}"] = str(new_ver_dir)
                        st.session_state.current_audio_ver = next_audio_ver

                        st.success(f"âœ… ìƒì„± ì™„ë£Œ! (í´ë”: {folder_name})")
                        st.rerun()
                        
                    except Exception as e:
                        st.error(f"ì—ëŸ¬: {e}")

        # ------------------------------------------------------------------
        # [UI] ì˜¤ë””ì˜¤ í™•ì¸ ë° í”Œë ˆì´ì–´
        # ------------------------------------------------------------------
        if current_audio_data:
            st.divider()
            
            # ë³€ìˆ˜ëª… ì—ëŸ¬ í•´ê²° ë¡œì§
            # selected_keyëŠ” (ëŒ€ë³¸ë²„ì „, ìŒì„±ë²„ì „) íŠœí”Œì…ë‹ˆë‹¤.
            if selected_key:
                cur_s, cur_a = selected_key
            else:
                # ì„ íƒëœ ê°’ì´ ì—†ë‹¤ë©´(ë°©ê¸ˆ ìƒì„±í–ˆê±°ë‚˜ ì´ˆê¸° ë¡œë“œ ì‹œ), 
                # í˜„ì¬ ëŒ€ë³¸ ë²„ì „ê³¼ (ë‹¤ìŒìƒì„±ë²ˆí˜¸ - 1)ì„ í˜„ì¬ ë²„ì „ìœ¼ë¡œ ê°„ì£¼
                cur_s = current_script_ver
                # next_audio_verëŠ” "ë‹¤ìŒì— ìƒì„±í•  ë²ˆí˜¸"ì´ë¯€ë¡œ, í˜„ì¬ ë³´ëŠ” ê±´ 1ì„ ë¹¼ì¤ë‹ˆë‹¤.
                # ë‹¨, ë°ì´í„°ê°€ ìˆëŠ”ë° nextê°€ 1ì´ë¼ë©´(ê¸°ì¡´ íŒŒì¼ ë¡œë“œ ì§í›„) ë¡œì§ì— ë”°ë¼ ì¡°ì • í•„ìš”
                cur_a = (next_audio_ver - 1) if next_audio_ver > 1 else 1
            
            # í˜„ì¬ ë¡œë“œëœ ë°ì´í„°ì˜ ì—”ì§„ ì •ë³´ í™•ì¸ (í‘œì‹œìš©)
            current_engine_display = "Unknown"
            try:
                cur_dir = st.session_state.get(f"loaded_tts_dir_{current_mode}")
                if cur_dir:
                    with open(Path(cur_dir) / "manifest.json", 'r', encoding='utf-8') as f:
                        m = json.load(f)
                        current_engine_display = m.get('engine', 'clova')
            except:
                pass

            st.markdown(f"### ğŸ§ ì˜¤ë””ì˜¤ í™•ì¸ (S{cur_s} / A{cur_a}) - {current_engine_display}")
            
            # í´ë” ê²½ë¡œ í‘œì‹œ (ë””ë²„ê¹…ìš©)
            current_path_display = st.session_state.get(f"loaded_tts_dir_{current_mode}", "New")
            # ì „ì²´ ê²½ë¡œ ëŒ€ì‹  í´ë”ëª…ë§Œ ê¹”ë”í•˜ê²Œ í‘œì‹œ
            display_short_path = Path(current_path_display).name if current_path_display != "New" else "New"
            st.caption(f"ğŸ“ ì €ì¥ ìœ„ì¹˜: .../{current_mode}/{display_short_path}")

            # 1. ì „ì²´ ë“£ê¸° (Full Audio)
            if current_full_audio and os.path.exists(current_full_audio):
                # ì „ì²´ ê¸¸ì´ ê³„ì‚°
                total_dur = sum([d["duration"] for d in current_audio_data if d.get("duration")])
                st.audio(current_full_audio)
                st.caption(f"â±ï¸ ì „ì²´ ê¸¸ì´: {total_dur:.1f}ì´ˆ")
            else:
                st.warning("âš ï¸ ì „ì²´ í†µí•© ì˜¤ë””ì˜¤ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")

            # 2. ê°œë³„ ë“£ê¸° (Segments)
            with st.expander(f"ğŸ“‚ ë¬¸ì¥ë³„ ìƒì„¸ ë“£ê¸° (S{cur_s}/A{cur_a})"):
                for i, item in enumerate(current_audio_data):
                    col_text, col_audio = st.columns([2, 1])
                    
                    with col_text:
                        spk = item.get('speaker', 'Unknown')
                        txt = item.get('text', '')
                        icon = "ğŸ“–" if spk == "narrator" else "ğŸ—£ï¸"
                        st.markdown(f"**#{i+1} {icon} [{spk}]**")
                        st.write(txt)
                    
                    with col_audio:
                        path = item.get("path")
                        if path and os.path.exists(path):
                            st.audio(path)
                            st.caption(f"{item.get('duration', 0):.1f}ì´ˆ")
                        else:
                            st.caption("ìŒì„± íŒŒì¼ ì—†ìŒ")
                    st.divider()

            # -------------------------------------------------------------
            # [Step 4 ì™„ë£Œ] -> Step 6 ì´ë™
            # -------------------------------------------------------------
            col_msg, col_btn = st.columns([3, 1])
            with col_msg:
                st.caption(f"í˜„ì¬ ì„ íƒëœ **Script v{cur_s} / Audio v{cur_a}** ìŒì„±ì„ í™•ì •í•˜ê³  ì´ë¯¸ì§€ ë§¤ì¹­ ë‹¨ê³„ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
            with col_btn:
                if st.button("âœ… ìŒì„± í™•ì • (Step 6 ì´ë™)"):
                    # 1. ì´ë¯¸ì§€ í´ë” ë° TXT ê²€ì¦
                    if not folder.exists():
                        st.error("ì´ë¯¸ì§€ í´ë” ê²½ë¡œê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    elif not txt_file.exists():
                        st.error("TXT íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
                    else:
                        with st.spinner("ì´ë¯¸ì§€ ë°ì´í„° ë¡œë“œ ì¤‘..."):
                            # A. ì´ë¯¸ì§€ í•„í„°ë§
                            valid_imgs = load_filtered_images(folder)
                            # B. í…ìŠ¤íŠ¸ íŒŒì‹±
                            text_map = parse_book_text_by_page(txt_file)
                            
                            # C. Candidates ìƒì„± (Step 6ìš© ë°ì´í„°)
                            candidates = []
                            for img_path in valid_imgs:
                                pg_num = extract_page_num_from_filename(img_path.name)
                                page_text = text_map.get(pg_num, "(í…ìŠ¤íŠ¸ ì—†ìŒ)")
                                candidates.append({
                                    "page_num": pg_num,
                                    "img_path": str(img_path),
                                    "img_name": img_path.name,
                                    "text": page_text
                                })
                            
                            # ì„¸ì…˜ì— ì¤‘ìš” ë°ì´í„° ì €ì¥ (ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìœ„í•´)
                            st.session_state.track_b_candidates = candidates
                            st.session_state.step2_audio = current_audio_data # í™•ì •ëœ ì˜¤ë””ì˜¤ ë¦¬ìŠ¤íŠ¸ ë„˜ê¹€
                            
                            # ë‹¨ê³„ ì´ë™
                            st.session_state.track_b_step = 6
                            st.toast(f"Audio v{cur_a} í™•ì •! Step 6ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                            st.rerun()
    # =========================================================
    # [Step 6] ì´ë¯¸ì§€ ìë™ ë§¤ì¹­ (ëŒ€ë³¸ ì¶œì²˜ ê¸°ë°˜ + ìŠ¤ë§ˆíŠ¸ ë¶„ë°°)
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 6:        
        # [DEBUG] Source Page ê°’ í™•ì¸ (í•„ìš”ì‹œ ì£¼ì„ ì²˜ë¦¬)
        if "step1_scripts" in st.session_state:
            with st.expander("ğŸ› [DEBUG] Step 3ì—ì„œ ë„˜ì–´ì˜¨ Source Page ê°’"):
                debug_data = [{
                    "Scene": i+1, 
                    "Source Page": item.get("source_page", "MISSING"),
                    "Type": type(item.get("source_page"))
                } for i, item in enumerate(st.session_state.step1_scripts)]
                st.dataframe(debug_data)

        st.info("âš¡ Step 3ì˜ í˜ì´ì§€ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ, ì¦‰ì‹œ ì´ë¯¸ì§€ë¥¼ ë°°ì •í•©ë‹ˆë‹¤. (í¼ì¹¨ë©´ ë° ì¤‘ë³µ ë°©ì§€ ê·œì¹™ ìë™ ì ìš©)")

        if "track_b_matches" not in st.session_state:
            st.session_state.track_b_matches = None

        if st.button("ğŸ§© ì´ë¯¸ì§€ ë°°ì • ì‹¤í–‰ (ì•Œê³ ë¦¬ì¦˜)", type="primary"):
            if not st.session_state.track_b_candidates:
                st.error("ì´ë¯¸ì§€ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            elif not st.session_state.step1_scripts:
                st.error("ëŒ€ë³¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            else:
                with st.spinner("ì´ë¯¸ì§€ ë°°ì • ê·œì¹™ ì ìš© ì¤‘..."):
                    
                    # -------------------------------------------------
                    # 0. ë°ì´í„° ì¤€ë¹„
                    # -------------------------------------------------
                    candidates = st.session_state.track_b_candidates
                    text_map = {item['page_num']: item['text'] for item in candidates}
                    spread_map = analyze_spread_structure(candidates)
                    
                    # [ìŠ¤í¬ì¼ëŸ¬ ìƒí•œì„  ê³„ì‚°]
                    target_text = st.session_state.get("target_trailer_text", "")
                    spoiler_limit_pg = find_spoiler_limit_page(target_text, text_map)
                    
                    # ì•ˆì „ì¥ì¹˜
                    max_book_pg = max(text_map.keys()) if text_map else 0
                    if spoiler_limit_pg > max_book_pg: spoiler_limit_pg = max_book_pg
                    if spoiler_limit_pg % 2 == 0: spoiler_limit_pg += 1

                    # í‘œì§€ í˜ì´ì§€ ë²ˆí˜¸
                    #cover_page_num = candidates[0]['page_num'] if candidates else 5
                    cover_page_num = find_cover_page_num(text_map, candidates)

                    #  Step 6.5ì—ì„œ ì“°ê¸° ìœ„í•´ ì„¸ì…˜ì— ì €ì¥
                    st.session_state['cover_page_num'] = cover_page_num

                    # -------------------------------------------------
                    # A. ëŒ€ë³¸ì—ì„œ í˜ì´ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (Direct Access)
                    # -------------------------------------------------
                    scripts = st.session_state.step1_scripts
                    total_scenes = len(scripts)
                    
                    # -------------------------------------------------
                    # B. ìŠ¤ë§ˆíŠ¸ ë°°ì¹˜ ë¡œì§
                    # -------------------------------------------------
                    final_selection = []
                    
                    def get_spread_id(pg):
                        info = spread_map.get(pg)
                        if info and info['pair_page']:
                            return min(pg, info['pair_page'])
                        return pg

                    # í—¬í¼: ì•ˆì „í•˜ê²Œ í˜ì´ì§€ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
                    def get_safe_page(idx):
                        if 0 <= idx < total_scenes:
                            val = scripts[idx].get("source_page", 0)
                            try: return int(val)
                            except: return 0
                        return -1

                    for i in range(total_scenes):
                        # 1. Step 3ì˜ ê°’ ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ê¸°
                        source_pg = get_safe_page(i)
                        scene_idx = i
                        note = "ëŒ€ë³¸ ì¶œì²˜"

                        # ìœ íš¨ì„± ê²€ì‚¬ (0ì´ê±°ë‚˜ ì´ë¯¸ì§€ ë§µì— ì—†ìœ¼ë©´ ìµœì†Œ í˜ì´ì§€ë¡œ ë³´ì •)
                        if source_pg != 0 and source_pg not in text_map:
                            if candidates:
                                source_pg = min(text_map.keys())
                                note = "ìœ íš¨í•˜ì§€ ì•Šì€ í˜ì´ì§€ ë³´ì •"
                            else:
                                source_pg=cover_page_num

                        # -----------------------------------------------
                        # Rule 0. ë§ˆì§€ë§‰ ì¥ë©´(Outro)ì€ source_page==0ì¼ ë•Œë§Œ í‘œì§€
                        # -----------------------------------------------
                        if i == total_scenes - 1 and source_pg == 0:
                            final_selection.append({
                                "scene_index": scene_idx,
                                "page": cover_page_num,
                                "original_pick": source_pg,
                                "note": "Rule: ë§ˆì§€ë§‰ ì¥ë©´(í‘œì§€, source_page=0)"
                            })
                            continue

                        # -----------------------------------------------
                        # Logic: ì—°ì† ì”¬ vs ë‹¨ë… ì”¬ ë¶„ê¸°
                        # -----------------------------------------------
                        # ì•ë’¤ ì”¬ì˜ Source Page ê°€ì ¸ì˜¤ê¸°
                        prev_pg_raw = get_safe_page(i-1)
                        next_pg_raw = get_safe_page(i+1)

                        curr_spread_id = get_spread_id(source_pg)
                        prev_spread_id = get_spread_id(prev_pg_raw) if i > 0 else -1
                        next_spread_id = get_spread_id(next_pg_raw) if i < total_scenes - 1 else -1

                        # í›„ë³´êµ° (Left, Right)
                        curr_info = spread_map.get(source_pg)
                        pair_pg = curr_info['pair_page'] if curr_info else None
                        
                        if pair_pg:
                            available_pages = sorted([source_pg, pair_pg])
                        else:
                            available_pages = [source_pg]
                        
                        final_pg = source_pg # ì´ˆê¸°ê°’

                        # Case 1: ì—°ì† ì¥ë©´ ì‹œì‘ (Start) -> ì™¼ìª½
                        if curr_spread_id == next_spread_id and curr_spread_id != prev_spread_id:
                            final_pg = available_pages[0] 
                            note += " + ì—°ì† ì‹œì‘(ì¢Œ)"

                        # Case 2: ì—°ì† ì¥ë©´ ì´ì–´ì§ (Continue) -> ì˜¤ë¥¸ìª½
                        elif curr_spread_id == prev_spread_id:
                            if len(available_pages) > 1:
                                final_pg = available_pages[1]
                                note += " + ì—°ì† ì´ì–´ì§(ìš°)"
                            else:
                                final_pg = available_pages[0]
                                note += " (ë‹¨ì¼ í˜ì´ì§€ ìœ ì§€)"

                        # Case 3: ë‹¨ë… ì¥ë©´ -> í…ìŠ¤íŠ¸ ì—†ëŠ” ìª½ ìš°ì„ 
                        else:
                            pair_info = spread_map.get(pair_pg) if pair_pg else None
                            if curr_info and curr_info['has_text'] and pair_info and not pair_info['has_text']:
                                final_pg = pair_pg
                                note += " (í…ìŠ¤íŠ¸ ì—†ëŠ” ìª½ ìš°ì„ )"

                        # -----------------------------------------------
                        # Rule: ìŠ¤í¬ì¼ëŸ¬ ìƒí•œì„ 
                        # -----------------------------------------------
                        if final_pg > spoiler_limit_pg:
                            final_pg = spoiler_limit_pg
                            note = f"ìŠ¤í¬ì¼ëŸ¬ ì œí•œ(Limit P.{spoiler_limit_pg})"

                        # -----------------------------------------------
                        # Rule: ì¤‘ë³µ ë°©ì§€
                        # -----------------------------------------------
                        if i > 0:
                            last_final_pg = final_selection[i-1]['page']
                            if final_pg == last_final_pg:
                                if pair_pg and pair_pg != final_pg:
                                    if pair_pg <= spoiler_limit_pg:
                                        final_pg = pair_pg
                                        note += " + ì¤‘ë³µ íšŒí”¼"
                        
                        # ê²°ê³¼ ì €ì¥
                        final_selection.append({
                            "scene_index": scene_idx,
                            "page": final_pg,
                            "original_pick": source_pg,
                            "note": note
                        })
                    
                    st.session_state.track_b_matches = final_selection
                    st.success(f"ë°°ì • ì™„ë£Œ! (ìŠ¤í¬ì¼ëŸ¬ ìƒí•œì„ : P.{spoiler_limit_pg})")

        # 3. ê²°ê³¼ í™•ì¸ UI
        if st.session_state.track_b_matches:
            matches = st.session_state.track_b_matches
            candidates_map = {c['page_num']: c for c in st.session_state.track_b_candidates}
            scripts = st.session_state.step1_scripts
            
            selected_filenames = [] 

            for i, match in enumerate(matches):
                pg = match['page']
                scene_text = scripts[i]['text']
                orig_pg = match['original_pick']
                
                st.divider()
                st.markdown(f"#### ğŸ¬ Scene {i+1} (Source: P.{orig_pg})")
                st.caption(f"ğŸ“œ {scene_text}")
                
                c1, c2 = st.columns([1, 2])
                with c1:
                    img_data = candidates_map.get(pg)
                    if img_data:
                        st.image(img_data['img_path'], width=300)
                        selected_filenames.append(img_data['img_name'])
                    else:
                        st.warning(f"Page {pg} ì´ë¯¸ì§€ ì—†ìŒ")
                        # ì˜ˆì™¸ì²˜ë¦¬: ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ì‚¬ìš©
                        if candidates_map:
                            first_key = sorted(list(candidates_map.keys()))[0]
                            st.image(candidates_map[first_key]['img_path'], width=300)
                            selected_filenames.append(candidates_map[first_key]['img_name'])

                with c2:
                    st.info(f"**ì„ íƒ:** Page {pg} | {match['note']}")
                    
                    all_options = sorted(list(candidates_map.keys()))
                    
                    # selectbox index ì•ˆì „ ì²˜ë¦¬
                    try:
                        sel_idx = all_options.index(pg)
                    except ValueError:
                        sel_idx = 0

                    new_pg = st.selectbox(
                        "ì´ë¯¸ì§€ êµì²´:", all_options, 
                        index=sel_idx,
                        key=f"manual_sel_{i}"
                    )
                    
                    if new_pg != pg:
                        st.session_state.track_b_matches[i]['page'] = new_pg
                        st.rerun()

            st.divider()
            
            col_msg, col_btn = st.columns([3, 1])
            with col_msg:
                st.caption(f"ì´ {len(selected_filenames)}ê°œì˜ ì¥ë©´ìœ¼ë¡œ ì˜ìƒì„ ìƒì„±í•©ë‹ˆë‹¤.")
            with col_btn:
                if st.button("ìµœì¢… í™•ì • (Step 7 ì˜ìƒ ìƒì„±)"):
                    st.session_state.selected_pages = selected_filenames
                    st.session_state.track_b_step = 7
                    st.toast("ì´ë¯¸ì§€ í™•ì •! ì˜ìƒ ìƒì„± ë‹¨ê³„ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.")
                    st.rerun()

   
    # =========================================================
    # [Step 7] Runway ì˜ìƒ ìƒì„± ë° ë³‘í•© (Visual & TTS)
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 7:
        # =========================================================
        # [Step 6.5] ì •ì§€ í™”ìƒ í”„ë¦¬ë·° (BGM: Title/nP ë¡œì§ ì ìš©)
        # =========================================================
        if st.session_state.get("track_b_step", 0) >= 7:
            st.divider()
            st.subheader("Step 6.5. (ì„ íƒ) ì •ì§€ í™”ìƒ í”„ë¦¬ë·° (Animatic)")
            st.info("ğŸï¸ Runway ì˜ìƒì„ ìƒì„±í•˜ê¸° ì „, [ì´ë¯¸ì§€ + TTS + ìë§‰ + BGM]ì˜ íë¦„ì„ ë¯¸ë¦¬ í™•ì¸í•´ë³´ì„¸ìš”.")
            
            # ---------------------------------------------------------
            # 0. ì˜ì¡´ì„± ë°ì´í„° ë° ê²½ë¡œ í™•ì¸
            # ---------------------------------------------------------
            cur_script_ver = st.session_state.get("current_script_ver", 1)
            cur_audio_ver = st.session_state.get("current_audio_ver", 1)
            cur_mode = st.session_state.get("script_style_mode", "Standard")

            story_dir_name = txt_file.stem
            # outputs / ë™í™”ì´ë¦„ / preview / ëª¨ë“œëª…
            PREVIEW_BASE_DIR = Path("outputs") / story_dir_name / "preview" / cur_mode
            PREVIEW_BASE_DIR.mkdir(parents=True, exist_ok=True)

            # BGM ê²½ë¡œ ì„¤ì • (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
            path_candidate_1 = Path("BGM") / story_dir_name
            path_candidate_2 = Path("BGM") / get_bgm_folder_name(story_dir_name)

            if path_candidate_1.exists() and path_candidate_1.is_dir():
                BGM_DIR = path_candidate_1
            elif path_candidate_2.exists() and path_candidate_2.is_dir():
                BGM_DIR = path_candidate_2
            else:
                BGM_DIR = path_candidate_1
            

            # ---------------------------------------------------------
            # 1. ë²„ì „ íƒìƒ‰ ë° ë¶ˆëŸ¬ì˜¤ê¸° (Load)
            # ---------------------------------------------------------
            sorted_keys, path_map = get_preview_versions(PREVIEW_BASE_DIR)
            
            selected_key = None
            
            # [UI] ë¶ˆëŸ¬ì˜¤ê¸° Selectbox
            if sorted_keys:
                col_sel, col_sp = st.columns([1, 2])
                with col_sel:
                    def format_func(key):
                        s, a, p = key 
    
                        # í•´ë‹¹ ë²„ì „ì˜ ëª¨ë¸ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ path_map(ë˜ëŠ” version_map) í™œìš©
                        model_hint = ""
                        try:
                            p_path = version_map[key] # í˜¹ì€ path_map[key] (ë³€ìˆ˜ëª… í™•ì¸ í•„ìš”)
                            if (p_path / "manifest.json").exists():
                                with open(p_path / "manifest.json", "r", encoding="utf-8") as f:
                                    m_data = json.load(f)
                                    eng = m_data.get("engine", "clova")
                                    model_hint = f" [{eng}]"
                        except:
                            pass
                        
                        is_latest = (key == sorted_keys[0])
                        # í™”ë©´ì— í‘œì‹œë  í…ìŠ¤íŠ¸ í˜•ì‹ (P ë²„ì „ë„ í¬í•¨)
                        return f"ğŸ“œv{s} â” ğŸ§v{a} â” ğŸ–¼ï¸v{p}{model_hint}" + (" (ìµœì‹ )" if is_latest else "")
                    selected_key = st.selectbox(
                        f"ğŸ“‚ '{current_mode}' í”„ë¦¬ë·°(Preview) ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°:", 
                        sorted_keys,
                        format_func=format_func,
                        key=f"prev_sel_{current_mode}"  # <--- 'tts_sel_' ëŒ€ì‹  'prev_sel_'ë¡œ ë³€ê²½
                    )
                
                # ì„ íƒëœ í´ë” ë¡œë“œ ë¡œì§
                target_dir = path_map[selected_key]
                
                # ì„¸ì…˜ ê°±ì‹  (ê²½ë¡œê°€ ë°”ë€Œì—ˆì„ ë•Œë§Œ)
                if st.session_state.get(f"loaded_prev_dir_{cur_mode}") != str(target_dir):
                    try:
                        with open(target_dir / "manifest.json", "r", encoding="utf-8") as f:
                            data = json.load(f)
                        st.session_state.track_b_preview_video = data.get("final_path", "")
                        st.session_state[f"loaded_prev_dir_{cur_mode}"] = str(target_dir)
                    except Exception as e:
                        st.error(f"ë¡œë“œ ì‹¤íŒ¨: {e}")

            # ë‹¤ìŒ í”„ë¦¬ë·° ë²„ì „ ê³„ì‚° (í˜„ì¬ S/A ì¡°í•© ë‚´ì—ì„œ)
            existing_p_vers = [k[2] for k in sorted_keys if k[0] == cur_script_ver and k[1] == cur_audio_ver]
            next_prev_ver = (max(existing_p_vers) + 1) if existing_p_vers else 1
                
            # ---------------------------------------------------------
            # 2. BGM ë° ì˜µì…˜ ì„¤ì • UI 
            # ---------------------------------------------------------
            def find_bgm_file(keywords, bgm_dir_path):
                if not bgm_dir_path.exists(): return None
                # í´ë” ë‚´ ëª¨ë“  ì˜¤ë””ì˜¤ íŒŒì¼ ê²€ìƒ‰
                for f in bgm_dir_path.iterdir():
                    if f.is_file() and f.suffix.lower() in ['.mp3', '.wav', '.m4a']:
                        # ì „ë‹¬ë°›ì€ í‚¤ì›Œë“œ(ì˜ˆ: '2P', '2p') ì¤‘ í•˜ë‚˜ë¼ë„ íŒŒì¼ëª…ì— ìˆìœ¼ë©´ ì„±ê³µ
                        for kw in keywords:
                            if kw in f.name: 
                                return f
                return None
            
            # ì„¸ì…˜ í‚¤ ì´ˆê¸°í™”
            if "track_b_preview_video" not in st.session_state:
                st.session_state.track_b_preview_video = None

            col_prev_info, col_prev_opt = st.columns([2, 2])
            
            with col_prev_info:
                st.caption("ì´ë¯¸ì§€, ì˜¤ë””ì˜¤, ìë§‰, BGMì„ í•©ì³ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")
            
            with col_prev_opt:
                use_bgm = st.checkbox("ğŸµ ë°°ê²½ìŒì•…(BGM) í¬í•¨í•˜ê¸°", value=False, key="step6_5_use_bgm")
                bgm_volume = 0.15
                
                if use_bgm:
                    if BGM_DIR.exists():
                        bgm_files = sorted(
                            [f for f in BGM_DIR.iterdir() if f.is_file() and f.suffix.lower() in ['.mp3', '.wav', '.m4a']],
                            key=lambda x: x.name
                        )
                        st.caption(f"ğŸ“‚ BGM í´ë”: {len(bgm_files)}ê°œ ì˜¤ë””ì˜¤ íŒŒì¼ ê°ì§€")
                        bgm_volume = st.slider("BGM ë³¼ë¥¨", 5, 100, 15, key="step6_5_bgm_vol") / 100.0
                    else:
                        st.warning(f" BGM í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤: {BGM_DIR}")
                        use_bgm = False

            # ---------------------------------------------------------
            # [UI] ìë§‰ ìŠ¤íƒ€ì¼ ì„ íƒ
            # ---------------------------------------------------------
            st.markdown("---")
            st.write("ğŸ¨ **ìë§‰ ìŠ¤íƒ€ì¼ ì„¤ì •**")
            subtitle_mode = st.radio(
                "ìë§‰ ìƒ‰ìƒ ë°©ì‹ì„ ì„ íƒí•˜ì„¸ìš”:",
                ["ğŸ³ï¸ ê¸°ë³¸ (í°ìƒ‰ í†µì¼)", "ğŸŒˆ ìºë¦­í„°ë³„ ìë™ ì»¬ëŸ¬ë§ (í™”ì êµ¬ë¶„)"],
                index=0,
                horizontal=True
            )
            # ---------------------------------------------------------
            # 3. í”„ë¦¬ë·° ìƒì„± ë¡œì§
            # ---------------------------------------------------------
            btn_label = f"ğŸï¸ í”„ë¦¬ë·° ìƒì„±í•˜ê¸° (S{cur_script_ver}/A{cur_audio_ver} â” Preview v{next_prev_ver})"
            
            if st.button(btn_label, type="primary", use_container_width=True):
                # 1. ë°ì´í„° ë¡œë“œ (ìˆœì„œ ì¤‘ìš”)
                matches = st.session_state.get("track_b_matches", [])
                audios = st.session_state.get("track_b_audio", [])
                scripts = st.session_state.get("step1_scripts", [])
                candidates = st.session_state.get("track_b_candidates", [])
                candidates_map = {c['page_num']: c for c in candidates}
                
                # 2. í‘œì§€(Cover) í˜ì´ì§€ ë²ˆí˜¸ í™•ì •
                # Step 6ì—ì„œ ì €ì¥ëœ ê°’ì´ ìˆìœ¼ë©´ ì“°ê³ , ì—†ìœ¼ë©´ candidates ì²«ë²ˆì§¸ ê°’ ì¶”ì •
                if 'cover_page_num' in st.session_state:
                    cover_page_num = st.session_state['cover_page_num']
                elif candidates:
                    cover_page_num = candidates[0]['page_num']
                else:
                    cover_page_num = 1 # ê¸°ë³¸ê°’

                # Step 1.5 ì •ë³´
                char_info = st.session_state.get("track_b_characters", {})
                dialogue_map = char_info.get("dialogue_map", []) if char_info else []
                current_mode = st.session_state.get("script_style_mode", "Standard")

                # [ë¡œì§] ì»¬ëŸ¬ë§ ëª¨ë“œì¼ ê²½ìš°ì—ë§Œ ë§µ ìƒì„±
                speaker_color_map = {}
                if "ì»¬ëŸ¬ë§" in subtitle_mode:
                    speaker_color_map = generate_dynamic_color_map(scripts)
                    st.caption(f"ğŸ¨ ì ìš©ëœ ìƒ‰ìƒ íŒ”ë ˆíŠ¸: {len(speaker_color_map)}ëª…ì˜ í™”ì êµ¬ë¶„ë¨")

                if not matches or not audios:
                    st.error("ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. Step 4, 6ì„ í™•ì¸í•´ì£¼ì„¸ìš”.")
                else:
                    # 2. í´ë” ìƒì„±: v{S}_{A}_{P}
                    folder_name = f"v{cur_script_ver}_{cur_audio_ver}_{next_prev_ver}"
                    NEW_VER_DIR = PREVIEW_BASE_DIR / folder_name
                    NEW_VER_DIR.mkdir(parents=True, exist_ok=True)

                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    temp_clips = []

                    try:
                        status_text.write(f"ğŸ”„ í”„ë¦¬ë·° ìƒì„± ì¤‘... (í‘œì§€: {cover_page_num}p ê¸°ì¤€)")
                        
                        for i, match in enumerate(matches):
                            # A. ê¸°ë³¸ ë°ì´í„°
                            pg = match['page']
                            img_info = candidates_map.get(pg)
                            if not img_info: continue
                            
                            img_path = str(img_info['img_path'])
                            audio_data = audios[i] if i < len(audios) else None
                            audio_path = audio_data['path'] if audio_data else None
                            audio_dur = audio_data['duration'] if (audio_data and audio_data['duration']) else 5.0

                            # B. ìë§‰ ë° ìƒ‰ìƒ ê²°ì •
                            script_item = scripts[i] if i < len(scripts) else {}
                            original_text = script_item.get("text", "")
                            current_speaker = str(script_item.get("speaker", "narrator")).strip()
                            
                            # â˜… ìƒ‰ìƒ ê²°ì • ë¡œì§
                            if "ì»¬ëŸ¬ë§" in subtitle_mode:
                                # ë§µì—ì„œ ì°¾ê±°ë‚˜ ì—†ìœ¼ë©´ í°ìƒ‰
                                text_color = speaker_color_map.get(current_speaker, "white")
                            else:
                                # ê¸°ë³¸ ëª¨ë“œ
                                text_color = "white"
                            
                            # â˜… ëŒ€ë³¸ìƒì˜ ì‹¤ì œ PDF í˜ì´ì§€ ë²ˆí˜¸ (ì˜ˆ: 5, 6, 7...)
                            source_page = script_item.get("source_page", 0) 
                            
                            subtitle_text = original_text 
                            if current_mode == "Conversation" and dialogue_map:
                                for d_item in dialogue_map:
                                    if (d_item.get("quote", "").strip() == original_text.strip()) and \
                                       (d_item.get("page_num") == source_page):
                                        subtitle_text = d_item.get("context")
                                        break
                            
                            # C. ê²½ë¡œ ì„¤ì •
                            base_clip_path = NEW_VER_DIR / f"preview_base_{i}.mp4"
                            sub_clip_path = NEW_VER_DIR / f"preview_sub_{i}.mp4"
                            final_clip_path = NEW_VER_DIR / f"preview_final_{i}.mp4"

                            # D. ì˜ìƒ ìƒì„± (ë¬´ìŒ) - PILë¡œ ì´ë¯¸ì§€ ì „ì²˜ë¦¬ í›„ í´ë¦½ ìƒì„±
                            from PIL import Image as PILImage
                            pil_img = PILImage.open(img_path).convert("RGB")
                            # ë†’ì´ 1280 ê¸°ì¤€ ë¦¬ì‚¬ì´ì¦ˆ
                            ratio = 1280 / pil_img.height
                            pil_img = pil_img.resize((int(pil_img.width * ratio), 1280), PILImage.LANCZOS)
                            # ê°€ìš´ë° 720px í¬ë¡­
                            left = (pil_img.width - 720) // 2
                            pil_img = pil_img.crop((left, 0, left + 720, 1280))
                            # numpy ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ImageClip ìƒì„±
                            import numpy as np
                            clip = ImageClip(np.array(pil_img), duration=audio_dur)
                            clip.fps = 24

                            clip.write_videofile(str(base_clip_path), codec="libx264", audio=False, preset="ultrafast", logger=None)
                            clip.close()

                            # E. ìë§‰ ì…íˆê¸°
                            # E. ìë§‰ ì…íˆê¸° (font_color ì¸ì ì‚¬ìš©)
                            add_subtitle_to_video(
                                str(base_clip_path), 
                                subtitle_text, 
                                str(sub_clip_path), 
                                scene_index=i, 
                                font_color=text_color 
                            )

                            # F. ì˜¤ë””ì˜¤ ë° BGM í•©ì„± (â˜… ì‚¬ìš©ì ìš”ì²­ ë¡œì§ ì ìš©)
                            if audio_path and os.path.exists(audio_path):
                                page_bgm = None
                                
                                if use_bgm and source_page >= 0:
                                    search_keywords = []
                                    
                                    # [Logic] í‘œì§€(Cover) í˜ì´ì§€ì¸ ê²½ìš° -> "title" ê²€ìƒ‰
                                    if source_page == cover_page_num:
                                        search_keywords = ["title", "Title", "TITLE"]
                                        log_msg = "Title(í‘œì§€)"
                                        
                                    elif source_page == 0:
                                        search_keywords = ["title", "Title", "TITLE"]
                                        log_msg = "Title(í‘œì§€)"

                                    # [Logic] í‘œì§€ë³´ë‹¤ ë’¤ìª½ í˜ì´ì§€ì¸ ê²½ìš° -> ìƒëŒ€ ë²ˆí˜¸ + "P" ê²€ìƒ‰
                                    elif source_page > cover_page_num:
                                        # ì˜ˆ: source_page(6) - cover(5) + 1 = 2 --> "2p"
                                        story_seq = source_page - cover_page_num + 1
                                        search_keywords = [f"{story_seq}p", f"{story_seq}P", f"Page {story_seq}", f"Page{story_seq}"]
                                        log_msg = f"{story_seq}p"

                                    # BGM íŒŒì¼ ì°¾ê¸°
                                    if search_keywords:
                                        page_bgm = find_bgm_file(search_keywords, BGM_DIR)

                                if page_bgm and page_bgm.exists():
                                    add_audio_to_video(
                                        str(sub_clip_path), str(audio_path), str(final_clip_path),
                                        bgm_path=str(page_bgm), bgm_volume=bgm_volume
                                    )
                                    st.caption(f"ğŸµ Scene {i+1} (PDF {source_page}p): [{log_msg}] â†’ '{page_bgm.name}' ì ìš©")
                                else:
                                    add_audio_to_video(
                                        str(sub_clip_path), str(audio_path), str(final_clip_path)
                                    )
                                
                                temp_clips.append(str(final_clip_path))
                            else:
                                temp_clips.append(str(sub_clip_path))

                            progress_bar.progress((i + 1) / len(matches))
                        
                        # ë³‘í•©
                        status_text.write(" ì „ì²´ ì˜ìƒ ë³‘í•© ì¤‘...")
                        final_preview_path = NEW_VER_DIR / "final_preview.mp4"
                        concat_videos_with_audio(temp_clips, str(final_preview_path))

                        # Manifest ì €ì¥
                        manifest = {
                            "script_ver": cur_script_ver,
                            "audio_ver": cur_audio_ver,
                            "preview_ver": next_prev_ver,
                            "created_at": str(datetime.now()),
                            "bgm_used": use_bgm,
                            "final_path": str(final_preview_path)
                        }
                        with open(NEW_VER_DIR / "manifest.json", "w", encoding="utf-8") as f:
                            json.dump(manifest, f, ensure_ascii=False, indent=4)
                        
                        st.session_state.track_b_preview_video = str(final_preview_path)
                        st.session_state[f"loaded_prev_dir_{cur_mode}"] = str(NEW_VER_DIR)

                        status_text.empty()
                        st.success(" í”„ë¦¬ë·° ìƒì„± ì™„ë£Œ!")
                      #  st.video(str(final_preview_path))

                    except Exception as e:
                        st.error(f"ì˜¤ë¥˜ ë°œìƒ: {e}")
                        st.text(traceback.format_exc())

        # í”„ë¦¬ë·° ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ í‘œì‹œ
        if st.session_state.get("track_b_preview_video") and os.path.exists(st.session_state.track_b_preview_video):
            st.divider()
            
            # ë²„ì „ ë¼ë²¨
            if selected_key:
                s, a, p = selected_key
                ver_label = f"S{s}/A{a}/P{p}"
            else:
                ver_label = f"S{cur_script_ver}/A{cur_audio_ver}/P{next_prev_ver-1}"
            
            st.markdown(f"#### ğŸ“º í”„ë¦¬ë·° í™•ì¸ ({ver_label})")
            st.video(st.session_state.track_b_preview_video)
            st.info("ğŸ‘† ìœ„ ì˜ìƒì€ 'ì´ë¯¸ì§€+TTS+ìë§‰' í™•ì¸ìš©ì…ë‹ˆë‹¤. ì‹¤ì œ ì˜ìƒ(Runway) ìƒì„±ì€ ì•„ë˜ 'Step 7'ì—ì„œ ì§„í–‰í•˜ì„¸ìš”.")

        # =========================================================
        # ì¶”í›„ ì½”ë“œ ì™„ì„± ì‹œ ì‚­ì œ ì˜ˆì •
        # =========================================================
        st.divider()
        st.subheader("Step 7. Runway ì˜ìƒ ìƒì„± ë° í’€ë²„ì „ ë³‘í•©")
        st.info("ğŸ¥ AI ì˜ìƒ ìƒì„± í›„, [ë¬´ìŒ í’€ë²„ì „]ê³¼ [TTS í¬í•¨ í’€ë²„ì „]ì„ ìë™ìœ¼ë¡œ ì œì‘í•©ë‹ˆë‹¤.")
        
        # 0. ë°ì´í„° ì¤€ë¹„
        if "track_b_video_results" not in st.session_state:
            st.session_state.track_b_video_results = [] 
        
        # ë³‘í•©ëœ íŒŒì¼ ê²½ë¡œ ì €ì¥ìš© ì„¸ì…˜
        if "track_b_full_visual" not in st.session_state:
            st.session_state.track_b_full_visual = None
        if "track_b_full_tts" not in st.session_state:
            st.session_state.track_b_full_tts = None

        # [ë²„ì „ ê´€ë¦¬] í˜„ì¬ ì‘ì—… ì¤‘ì¸ ëŒ€ë³¸/ìŒì„± ë²„ì „ í™•ì¸
        cur_script_ver = st.session_state.get("current_script_ver", 1)
        cur_audio_ver = st.session_state.get("current_audio_ver", 1)
        cur_mode = st.session_state.get("script_style_mode", "Standard")

        # ë°ì´í„° ê²€ì¦
        if not st.session_state.track_b_matches:
            st.error("Step 6ì—ì„œ ì´ë¯¸ì§€ ë§¤ì¹­ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.")
        elif not st.session_state.track_b_audio:
            st.error("Step 4ì—ì„œ TTS ìƒì„±ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.")
        else:
            # ê¸°ë³¸ ê²½ë¡œ ì„¤ì •: outputs/ë™í™”ì´ë¦„/video/ëª¨ë“œëª…
            story_dir_name = txt_file.stem
            VIDEO_BASE_DIR = Path("outputs") / story_dir_name / "video" / cur_mode
            VIDEO_BASE_DIR.mkdir(parents=True, exist_ok=True)

            # ------------------------------------------------------------------
            # [ë¡œë“œ ë¡œì§] ê¸°ì¡´ ë²„ì „ íƒìƒ‰ ë° ë¶ˆëŸ¬ì˜¤ê¸°
            # ------------------------------------------------------------------
            sorted_keys, path_map = get_video_versions_v3(VIDEO_BASE_DIR)
            
            selected_key = None
            current_ver_dir = None # í˜„ì¬ ë¡œë“œëœ í´ë” ê²½ë¡œ
            
            if sorted_keys:
                col_sel, col_space = st.columns([1, 2])
                with col_sel:
                    def format_func(k):
                        s, a, v = k
                        is_match = (s == cur_script_ver and a == cur_audio_ver)
                        prefix = "âœ… " if is_match else ""
                        is_latest = (k == sorted_keys[0])
                        return f"{prefix}S{s}/A{a} â” Video v{v}" + (" (ìµœì‹ )" if is_latest else "")

                    selected_key = st.selectbox(
                        f"ğŸ“‚ '{cur_mode}' ì˜ìƒ ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°:",
                        sorted_keys,
                        format_func=format_func,
                        key=f"vid_sel_{cur_mode}"
                    )
                
                # ì„ íƒëœ í´ë” ë¡œë“œ
                current_ver_dir = path_map[selected_key]
                
                # ì„¸ì…˜ ë¡œë“œ (ê²½ë¡œê°€ ë°”ë€Œì—ˆì„ ë•Œë§Œ)
                if st.session_state.get(f"loaded_vid_dir_{cur_mode}") != str(current_ver_dir):
                    try:
                        with open(current_ver_dir / "manifest.json", "r", encoding="utf-8") as f:
                            data = json.load(f)
                        
                        st.session_state.track_b_video_results = data.get("clips", [])
                        st.session_state.track_b_full_visual = data.get("full_visual_path", "")
                        st.session_state[f"loaded_vid_dir_{cur_mode}"] = str(current_ver_dir)
                    except Exception as e:
                        st.error(f"ë¡œë“œ ì‹¤íŒ¨: {e}")
            
            # ë‹¤ìŒ ì˜ìƒ ë²„ì „ ê³„ì‚° (í˜„ì¬ S/A ì¡°í•© ê¸°ì¤€)
            existing_v_vers = [k[2] for k in sorted_keys if k[0] == cur_script_ver and k[1] == cur_audio_ver]
            next_video_ver = (max(existing_v_vers) + 1) if existing_v_vers else 1
            
            # 1. ì„¤ì • UI
            with st.container(border=True):
                col_p, col_d = st.columns([3, 1])
                with col_p:
                    global_prompt = st.text_input(
                        "ğŸ¨ ëª¨ì…˜ í”„ë¡¬í”„íŠ¸ (ì˜ìƒ ìŠ¤íƒ€ì¼/ì›€ì§ì„):", 
                        value="Characters and elements within a children's book illustration move, as if coming to life, with gentle cinematic movement, without adding anything new.",
                        help="ëª¨ë“  ì¥ë©´ì— ê³µí†µìœ¼ë¡œ ì ìš©ë  ì›€ì§ì„ ì§€ì‹œì–´ì…ë‹ˆë‹¤."
                    )
                with col_d:
                    default_dur_input = st.number_input("ê¸°ë³¸ ê¸¸ì´(ì´ˆ):", min_value=5, max_value=5, value=5)

            # 2. ë¯¸ë¦¬ë³´ê¸°
            with st.expander(" ìƒì„± ëŒ€ê¸°ì—´ í™•ì¸", expanded=False):
                matches = st.session_state.track_b_matches
                audios = st.session_state.track_b_audio
                candidates_map = {c['page_num']: c for c in st.session_state.track_b_candidates}
                
                preview_data = []
                for i, match in enumerate(matches):
                    pg = match['page']
                    audio_dur = audios[i]['duration'] if i < len(audios) and audios[i] else None
                    gen_seconds = (5 if audio_dur <= 6.0 else 10) if audio_dur else default_dur_input
                    preview_data.append({
                        "Scene": i+1, "Page": pg, 
                        "TTS Len": f"{audio_dur:.1f}s" if audio_dur else "N/A",
                        "Gen Len": f"{gen_seconds}s"
                    })
                st.dataframe(preview_data)

            # 3. ì‹¤í–‰ ë²„íŠ¼
            has_results = len(st.session_state.track_b_video_results) > 0
            # ë²„íŠ¼ ë¼ë²¨ì— ë²„ì „ ì •ë³´ í‘œì‹œ
            btn_label = f" ì˜ìƒ ìƒì„± (S{cur_script_ver}/A{cur_audio_ver} â” Video v{next_video_ver})"
            
            if st.button(btn_label, type="primary"):
                # UID ìƒì„±
                uid = uuid.uuid4().hex[:6]
                
                # [ë²„ì „ ê´€ë¦¬] í´ë” êµ¬ì¡° ìƒì„±: v{S}_{A}_{V}
                folder_name = f"v{cur_script_ver}_{cur_audio_ver}_{next_video_ver}"
                
                # BASE_OUTì„ ë²„ì „ë³„ í´ë”ë¡œ ì„¤ì •
                BASE_OUT = VIDEO_BASE_DIR / folder_name
                
                RAW_DIR = BASE_OUT / "raw"
                TRIMMED_DIR = BASE_OUT / "trimmed"
                # FULL_DIR, FULL_TTS_DIR ë“±ì€ ì´ í´ë” êµ¬ì¡°ì— ë§ê²Œ í†µí•©
                
                BASE_OUT.mkdir(parents=True, exist_ok=True)
                RAW_DIR.mkdir(parents=True, exist_ok=True)
                TRIMMED_DIR.mkdir(parents=True, exist_ok=True)
                
                generated_data_list = []
                progress_bar = st.progress(0)
                status_text = st.empty()
                total_scenes = len(matches)

                try:
                    # =================================================
                    # [Part A] ê°œë³„ ì˜ìƒ ìƒì„± ë° íŠ¸ë¦¬ë°
                    # =================================================
                    for i, match in enumerate(matches):
                        pg = match['page']
                        img_info = candidates_map.get(pg)
                        if not img_info: continue
                        img_path = str(img_info['img_path'])
                        
                        audio_dur = audios[i]['duration'] if i < len(audios) and audios[i] else None
                        
                        if audio_dur is None:
                            runway_dur = default_dur_input; target_trim_dur = default_dur_input
                        else:
                            runway_dur = 5 if audio_dur <= 6.0 else 10
                            target_trim_dur = audio_dur

                        status_text.write(f" Scene {i+1}/{total_scenes}: Runway ìƒì„±({runway_dur}s) ë° ìë¥´ê¸°({target_trim_dur:.1f}s)...")

                        # Runway í˜¸ì¶œ
                        result_json = generate_video_from_image(img_path, global_prompt, runway_dur)
                        video_url = extract_video_url(result_json)

                        if not video_url:
                            st.error(f"Scene {i+1} ìƒì„± ì‹¤íŒ¨")
                            continue

                        # ì €ì¥ (RAW_DIRëŠ” ë²„ì „ë³„ í´ë”)
                        raw_filename = f"scene_{i+1:02d}_{uid}_raw.mp4"
                        raw_path = RAW_DIR / raw_filename
                        download_video(video_url, raw_path)

                        # íŠ¸ë¦¬ë° (TRIMMED_DIRëŠ” ë²„ì „ë³„ í´ë”)
                        final_filename = f"scene_{i+1:02d}_{uid}_trimmed.mp4"
                        final_path = TRIMMED_DIR / final_filename

                        # 3. ê¸¸ì´ ì¡°ì ˆ
                        final_filename = f"scene_{i+1:02d}_{uid}_trimmed.mp4"
                        final_path = TRIMMED_DIR / final_filename

                        # MoviePyë¡œ ë¡œë“œ
                        clip = VideoFileClip(str(raw_path))
                        
                        if target_trim_dur <= runway_dur:
                            # Case A: ì˜ìƒì´ ì˜¤ë””ì˜¤ë³´ë‹¤ ê¹€ (ì˜ˆ: ì˜ìƒ 5ì´ˆ > ì˜¤ë””ì˜¤ 1.6ì´ˆ)
                            # -> ê·¸ëƒ¥ ì˜¤ë””ì˜¤ ê¸¸ì´ì— ë§ì¶°ì„œ ë’¤ë¥¼ ì˜ë¼ë²„ë¦¼ (Trim)
                            final_clip = clip.subclip(0, target_trim_dur)
                            st.caption(f"âœ‚ï¸ Scene {i+1}: ìë¥´ê¸° (Trim) ({runway_dur}s â†’ {target_trim_dur:.1f}s)")
                        
                        else:
                            # Case B: ì˜ìƒì´ ì˜¤ë””ì˜¤ë³´ë‹¤ ì§§ìŒ (ì˜ˆ: ì˜ìƒ 5ì´ˆ < ì˜¤ë””ì˜¤ 6.0ì´ˆ)
                            # -> ì˜ìƒì„ ì˜¤ë””ì˜¤ ê¸¸ì´ë§Œí¼ ëŠë¦¬ê²Œ ëŠ˜ë¦¼ (Stretch / Slow Motion)
                            # vfx.speedxë¥¼ ì“°ë©´ final_durationì— ë§ì¶° ì†ë„ë¥¼ ìë™ ì¡°ì ˆí•´ì¤ë‹ˆë‹¤.
                            final_clip = clip.fx(vfx.speedx, final_duration=target_trim_dur)
                            st.caption(f"ğŸ¢ Scene {i+1}: ëŠ˜ë¦¬ê¸° (Slow) ({runway_dur}s â†’ {target_trim_dur:.1f}s)")
                        
                        # ì²˜ë¦¬ëœ ì˜ìƒ ì €ì¥
                        final_clip.write_videofile(
                            str(final_path), 
                            fps=24, 
                            codec="libx264", 
                            audio=False, # ì˜¤ë””ì˜¤ ì—†ëŠ” ìƒíƒœë¡œ ì €ì¥
                            logger=None  # ë¡œê·¸ ìˆ¨ê¹€
                        )
                        clip.close()
                        final_clip.close()
                        
                        generated_data_list.append({"raw": str(raw_path), "trimmed": str(final_path)})
                        progress_bar.progress((i + 1) / total_scenes)

                    st.session_state.track_b_video_results = generated_data_list


                    # =================================================
                    # [Part B] ì „ì²´ ì˜ìƒ ë³‘í•© (Visual Only)
                    # =================================================
                    if generated_data_list:
                        status_text.write("ğŸ”— ì „ì²´ ì˜ìƒ(ë¬´ìŒ) ë³‘í•© ì¤‘...")
                        
                        # Visual Only (ë¬´ìŒ ë³‘í•©)
                        clips_vis = [VideoFileClip(d['trimmed']) for d in generated_data_list]
                        final_clip_vis = concatenate_videoclips(clips_vis, method="compose")
                        
                        # Full íŒŒì¼ë„ ë²„ì „ í´ë” ì•ˆì— ì €ì¥
                        full_vis_path = BASE_OUT / f"full_visual_{uid}.mp4"
                        final_clip_vis.write_videofile(
                            str(full_vis_path), fps=24, codec="libx264", audio=False, logger=None
                        )
                        full_str = str(full_vis_path)
                        
                        for c in clips_vis: c.close()

                    # [ì €ì¥] Manifest íŒŒì¼ ìƒì„± (ë²„ì „ ê´€ë¦¬ í•µì‹¬)
                    manifest = {
                        "script_ver": cur_script_ver,
                        "audio_ver": cur_audio_ver,
                        "video_ver": next_video_ver,
                        "created_at": str(datetime.now()),
                        "prompt": global_prompt,
                        "full_visual_path": full_str,
                        "clips": generated_data_list
                    }
                    with open(BASE_OUT / "manifest.json", "w", encoding="utf-8") as f:
                        json.dump(manifest, f, ensure_ascii=False, indent=4)

                    # ì„¸ì…˜ ê°±ì‹ 
                    st.session_state.track_b_video_results = generated_data_list
                    st.session_state.track_b_full_visual = full_str
                    st.session_state[f"loaded_vid_dir_{cur_mode}"] = str(BASE_OUT)

                    st.success(f" ì˜ìƒ ìƒì„± ì™„ë£Œ! (ë²„ì „: S{cur_script_ver}/A{cur_audio_ver}/V{next_video_ver})")
                    st.rerun()
                    
                except Exception as e:
                    st.error(f"ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

            # 4. ê²°ê³¼ í™•ì¸ ë° ê°œë³„ ì¬ìƒì„±
            if st.session_state.track_b_video_results:
                
                # [ìƒë‹¨] ë¬´ìŒ ë³‘í•© ê²°ê³¼ë¬¼ í™•ì¸
                if st.session_state.track_b_full_visual and os.path.exists(st.session_state.track_b_full_visual):
                    st.divider()
                    
                    # í˜„ì¬ ë³´ì—¬ì£¼ëŠ” ë²„ì „ ì •ë³´ í‘œì‹œ
                    ver_info = selected_key if selected_key else (cur_script_ver, cur_audio_ver, next_video_ver - 1)
                    st.markdown(f"#### ì „ì²´ ë³‘í•© ì˜ìƒ (S{ver_info[0]}/A{ver_info[1]}/V{ver_info[2]})")
                    
                    st.video(st.session_state.track_b_full_visual)
                    with open(st.session_state.track_b_full_visual, "rb") as f:
                        st.download_button(" ë¬´ìŒ ì˜ìƒ ë‹¤ìš´ë¡œë“œ", f, file_name="full_visual.mp4", mime="video/mp4")

                # [í•˜ë‹¨] ê°œë³„ ì”¬ í™•ì¸ ë° ìˆ˜ì • (In-Place Regeneration)
                with st.expander(" ê°œë³„ ì”¬(Scene) ìƒì„¸ í™•ì¸ ë° ìˆ˜ì •", expanded=True):
                    cols = st.columns(3)
                    
                    # ì¬ìƒì„± ì‹œ í•„ìš”í•œ í˜„ì¬ ë¡œë“œëœ í´ë” ê²½ë¡œ
                    current_loaded_dir = Path(st.session_state.get(f"loaded_vid_dir_{cur_mode}", ""))
                    
                    for i, vid_data in enumerate(st.session_state.track_b_video_results):
                        # ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ìŠ¤í‚µ
                        if not vid_data.get('raw'): continue

                        with cols[i % 3]:
                            st.markdown(f"**Scene {i+1}**")
                            
                            tab_trim, tab_raw = st.tabs(["âœ‚ï¸ Trim", "ğŸï¸ Raw"])
                            with tab_trim:
                                if os.path.exists(vid_data['trimmed']): st.video(vid_data['trimmed'])
                            with tab_raw:
                                if os.path.exists(vid_data['raw']): st.video(vid_data['raw'])
                            
                            # =========================================================
                            # [ê°œë³„ ì¬ìƒì„± ë²„íŠ¼ ë¡œì§]
                            # =========================================================
                            if st.button(f"ğŸ”„ Scene {i+1} ë‹¤ì‹œ ìƒì„±", key=f"regen_btn_{i}"):
                                try:
                                    if not current_loaded_dir.exists():
                                        st.error("ì €ì¥ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œë“œí•´ì£¼ì„¸ìš”.")
                                    else:
                                        status_text_regen = st.empty()
                                        status_text_regen.info(f"â³ Scene {i+1} ë‹¤ì‹œ ìƒì„± ì¤‘...")
                                        
                                        # 1. ì •ë³´ ì¤€ë¹„
                                        match = matches[i]
                                        img_info = candidates_map.get(match['page'])
                                        img_path = str(img_info['img_path'])
                                        
                                        audio_dur = audios[i]['duration'] if i < len(audios) and audios[i] else None
                                        
                                        if audio_dur is None:
                                            runway_dur = default_dur_input; target_trim_dur = default_dur_input
                                        else:
                                            runway_dur = 5 if audio_dur <= 6.0 else 10
                                            target_trim_dur = audio_dur
                                        
                                        # 2. Runway ì¬ìƒì„±
                                        result_json = generate_video_from_image(img_path, global_prompt, runway_dur)
                                        video_url = extract_video_url(result_json)
                                        
                                        if video_url:
                                            # 3. íŒŒì¼ ë®ì–´ì“°ê¸° (í˜„ì¬ ë²„ì „ í´ë” ë‚´ì˜ íŒŒì¼)
                                            # vid_data['raw'] ê²½ë¡œê°€ ì ˆëŒ€ ê²½ë¡œì—¬ì•¼ í•¨.
                                            raw_p = Path(vid_data['raw'])
                                            trim_p = Path(vid_data['trimmed'])
                                            
                                            download_video(video_url, raw_p)
                                            
                                            # 4. ë‹¤ì‹œ íŠ¸ë¦¬ë°
                                            clip = VideoFileClip(str(raw_p))
                                            if target_trim_dur <= runway_dur:
                                                final_clip = clip.subclip(0, target_trim_dur)
                                            else:
                                                final_clip = clip.fx(vfx.speedx, final_duration=target_trim_dur)
                                            
                                            final_clip.write_videofile(
                                                str(trim_p), fps=24, codec="libx264", audio=False, logger=None
                                            )
                                            clip.close(); final_clip.close()
                                            
                                            # 5. ì „ì²´ ë³‘í•© ë‹¤ì‹œ (í˜„ì¬ í´ë”ì˜ ëª¨ë“  í´ë¦½ìœ¼ë¡œ)
                                            status_text_regen.info(" ì „ì²´ ì˜ìƒ ê°±ì‹  ì¤‘...")
                                            
                                            # í˜„ì¬ ì„¸ì…˜ ë°ì´í„° ê¸°ì¤€ìœ¼ë¡œ ë³‘í•©
                                            all_clips_paths = [d['trimmed'] for d in st.session_state.track_b_video_results]
                                            clips_vis = [VideoFileClip(p) for p in all_clips_paths]
                                            final_clip_vis = concatenate_videoclips(clips_vis, method="compose")
                                            
                                            full_vis_path = current_loaded_dir / f"full_visual_updated_{uuid.uuid4().hex[:4]}.mp4"
                                            final_clip_vis.write_videofile(
                                                str(full_vis_path), fps=24, codec="libx264", audio=False, logger=None
                                            )
                                            for c in clips_vis: c.close()
                                            
                                            # ì„¸ì…˜ ë° Manifest ì—…ë°ì´íŠ¸
                                            st.session_state.track_b_full_visual = str(full_vis_path)
                                            
                                            # Manifest íŒŒì¼ ê°±ì‹  (Full Pathê°€ ë°”ë€Œì—ˆìœ¼ë¯€ë¡œ)
                                            manifest_path = current_loaded_dir / "manifest.json"
                                            if manifest_path.exists():
                                                with open(manifest_path, "r", encoding="utf-8") as f:
                                                    m_data = json.load(f)
                                                m_data['full_visual_path'] = str(full_vis_path)
                                                with open(manifest_path, "w", encoding="utf-8") as f:
                                                    json.dump(m_data, f, ensure_ascii=False, indent=4)
                                            
                                            st.success("ì¬ìƒì„± ë° ë³‘í•© ì™„ë£Œ!")
                                            st.rerun()
                                        else:
                                            st.error("Runway ìƒì„± ì‹¤íŒ¨")
                                        
                                except Exception as e:
                                    st.error(f"ê°œë³„ ì¬ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")

                # 5. Step 8 ì´ë™ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
                st.divider()
                col_m, col_b = st.columns([3, 1])
                with col_m:
                    st.caption("ì˜ìƒ ì†ŒìŠ¤ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ì˜¤ë””ì˜¤ í•©ì„± ë° ìë§‰ ì‘ì—…(Step 8)ìœ¼ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
                with col_b:
                    if st.button(" Step 8 ì´ë™ (ìµœì¢…ì‘ì—…)"):
                        story_dir_name = txt_file.stem
                        st.session_state.track_b_output_dirs = {
                            "root": str(Path("outputs") / story_dir_name),
                            "full": str(st.session_state.track_b_full_visual)
                        }
                        st.session_state.track_b_step = 8
                        st.session_state.current_script_ver = cur_script_ver
                        st.session_state.current_audio_ver  = cur_audio_ver
                        st.session_state.current_video_ver  = next_video_ver
                        st.toast("Step 8: ìë§‰ ë° ìµœì¢… í¸ì§‘ ë‹¨ê³„ë¡œ ì´ë™í•©ë‹ˆë‹¤.")
                        st.rerun()

    # =========================================================
    # [Step 8] ìµœì¢… ì™„ì„±: ì˜¤ë””ì˜¤ í•©ì„± ë° ìë§‰ ìƒì„±
    # =========================================================
    if st.session_state.get("track_b_step", 0) >= 8:
        st.divider()
        st.subheader("Step 8. ìµœì¢… ì˜ìƒ ì™„ì„± (ì˜¤ë””ì˜¤ + ìë§‰)")
        st.info(" ê°œë³„ ì˜ìƒì— TTS ìŒì„±ê³¼ ìë§‰ì„ ì…íŒ ë’¤, ìµœì¢… ê²°ê³¼ë¬¼ë¡œ í•©ì¹©ë‹ˆë‹¤.")

        # 0. í•„ìš”í•œ ë°ì´í„° í™•ì¸
        matches = st.session_state.get("track_b_matches", [])
        audios = st.session_state.get("track_b_audio", [])
        video_results = st.session_state.get("track_b_video_results", [])
        scripts = st.session_state.get("step1_scripts", [])

        # Step 1.5 ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë§¤ì¹­ìš©)
        char_info = st.session_state.get("track_b_characters", {})
        dialogue_map = char_info.get("dialogue_map", []) if char_info else []
        
        # í˜„ì¬ ëª¨ë“œ í™•ì¸ (Step 3ì—ì„œ ì„¤ì •í•œ session_state ê°’)
        # ë§Œì•½ ê°’ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ 'Standard'ë¡œ ê°€ì •
        current_mode = st.session_state.get("script_style_mode", "Standard")

        if not video_results or not audios or not scripts:
            st.error("ì´ì „ ë‹¨ê³„ì˜ ë°ì´í„°(ì˜ìƒ, ì˜¤ë””ì˜¤, ëŒ€ë³¸)ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. Step 7ì„ ë¨¼ì € ì™„ë£Œí•´ì£¼ì„¸ìš”.")
        else:
            # ------------------------------------------------------------------
            # [ë²„ì „ ì¶”ì ] í˜„ì¬ ì‘ì—… ì¤‘ì¸ S/A/V ë²„ì „ íŒŒì•…
            # ------------------------------------------------------------------
            # Step 7ì—ì„œ ë¡œë“œëœ ì˜ìƒ í´ë”ëª…(v1_1_1)ì—ì„œ ë²„ì „ì„ ì—­ì¶”ì í•©ë‹ˆë‹¤.
            cur_s = st.session_state.get("current_script_ver")
            cur_a = st.session_state.get("current_audio_ver")
            cur_v = st.session_state.get("current_video_ver")

            if not (cur_s and cur_a and cur_v):
                # fallback: ê¸°ì¡´ì²˜ëŸ¼ loaded_vid_dir íŒŒì‹±
                loaded_vid_dir = st.session_state.get(f"loaded_vid_dir_{current_mode}", "")
                try:
                    dir_name = Path(loaded_vid_dir).name
                    m = re.match(r"^v(\d+)_(\d+)_(\d+)$", dir_name)
                    if m:
                        cur_s, cur_a, cur_v = map(int, m.groups())
                    else:
                        raise ValueError
                except:
                    cur_s = st.session_state.get("current_script_ver", 1)
                    cur_a = st.session_state.get("current_audio_ver", 1)
                    cur_v = 1

            # ê¸°ë³¸ ê²½ë¡œ: outputs/ë™í™”ëª…/final/ëª¨ë“œëª…
            story_dir_name = txt_file.stem
            FINAL_BASE_DIR = Path("outputs") / story_dir_name / "final" / current_mode
            FINAL_BASE_DIR.mkdir(parents=True, exist_ok=True)

            # ------------------------------------------------------------------
            # [ë¡œë“œ ë¡œì§] ê¸°ì¡´ Final ë²„ì „ íƒìƒ‰
            # ------------------------------------------------------------------
            sorted_keys, path_map = get_final_versions(FINAL_BASE_DIR)
            
            selected_key = None
            
            if sorted_keys:
                col_sel, col_space = st.columns([1, 2])
                with col_sel:
                    def format_func(k):
                        s, a, v, f = k
                        is_match = (s == cur_s and a == cur_a and v == cur_v)
                        prefix = "âœ… " if is_match else ""
                        is_latest = (k == sorted_keys[0])
                        return f"{prefix}S{s}/A{a}/V{v} â” Final v{f}" + (" (ìµœì‹ )" if is_latest else "")

                    selected_key = st.selectbox(
                        f" '{current_mode}' ìµœì¢…ë³¸ ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°:",
                        sorted_keys,
                        format_func=format_func,
                        key=f"final_sel_{current_mode}"
                    )
                
                # ì„ íƒëœ í´ë” ë¡œë“œ
                target_dir = path_map[selected_key]
                if st.session_state.get(f"loaded_final_dir_{current_mode}") != str(target_dir):
                    try:
                        with open(target_dir / "manifest.json", "r", encoding="utf-8") as f:
                            data = json.load(f)
                        st.session_state.track_b_final_movie = data.get("final_movie_path", "")
                        st.session_state[f"loaded_final_dir_{current_mode}"] = str(target_dir)
                    except Exception as e:
                        st.error(f"ë¡œë“œ ì‹¤íŒ¨: {e}")

            # ë‹¤ìŒ Final ë²„ì „ ê³„ì‚° (í˜„ì¬ S/A/V ì¡°í•© ë‚´ì—ì„œ)
            # ì˜ˆ: v1_1_1_1, v1_1_1_2ê°€ ìˆìœ¼ë©´ nextëŠ” 3
            existing_finals = [k[3] for k in sorted_keys if k[0]==cur_s and k[1]==cur_a and k[2]==cur_v]
            next_final_ver = (max(existing_finals) + 1) if existing_finals else 1


            # =======================================
            # ğŸµ BGM ì„¤ì • ì„¹ì…˜
            # =======================================
            st.markdown("---")
            st.markdown("#### ğŸµ ë°°ê²½ìŒì•…(BGM) ì„¤ì •")

            # ---------------------------------------------------------
            # [BGM ê²½ë¡œ ì„¤ì •] OR ë¡œì§ ì ìš© (ìš°ì„ ìˆœìœ„ ì²´í¬)
            # ---------------------------------------------------------
            story_dir_name = txt_file.stem

            # í›„ë³´ 1: íŒŒì¼ëª… ê·¸ëŒ€ë¡œ ì‚¬ìš© (Step 6.5 ë°©ì‹)
            path_candidate_1 = Path("BGM") / story_dir_name

            # í›„ë³´ 2: ë³€í™˜ í•¨ìˆ˜ ì‚¬ìš© (Step 8 ë°©ì‹)
            # (ì£¼ì˜: get_bgm_folder_name í•¨ìˆ˜ê°€ ì½”ë“œ ìƒë‹¨ì— ì •ì˜ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤)
            path_candidate_2 = Path("BGM") / get_bgm_folder_name(story_dir_name)

            # [ë¡œì§] 1ë²ˆì´ ìˆìœ¼ë©´ 1ë²ˆ, ì—†ìœ¼ë©´ 2ë²ˆ, ë‘˜ ë‹¤ ì—†ìœ¼ë©´ 1ë²ˆì„ ê¸°ë³¸ê°’ìœ¼ë¡œ
            if path_candidate_1.exists() and path_candidate_1.is_dir():
                BGM_DIR = path_candidate_1
                st.caption(f"BGM ê²½ë¡œ í™•ì¸ë¨ (Type A): {BGM_DIR}")
            elif path_candidate_2.exists() and path_candidate_2.is_dir():
                BGM_DIR = path_candidate_2
                st.caption(f"BGM ê²½ë¡œ í™•ì¸ë¨ (Type B): {BGM_DIR}")
            else:
                BGM_DIR = path_candidate_1  # í´ë”ê°€ ì—†ì„ ê²½ìš° ê¸°ë³¸ê°’

            use_bgm = st.checkbox("ë°°ê²½ìŒì•… ì‚¬ìš© (í˜ì´ì§€ë³„ ìë™ ë§¤ì¹­)", value=False, key="step8_use_bgm")
            bgm_volume = 0.15

            if use_bgm:
                if BGM_DIR.exists():
                    bgm_files = sorted([f.name for f in BGM_DIR.iterdir() if f.suffix.lower() in ['.wav', '.mp3', '.m4a']])
                    if bgm_files:
                        bgm_volume = st.slider("BGM ë³¼ë¥¨ (%):", 5, 100, 15, key="step8_bgm_volume") / 100.0
                        st.info(f" BGM í´ë” ë°œê²¬: {len(bgm_files)}ê°œ íŒŒì¼")
                        st.caption("ê° í˜ì´ì§€ ë²ˆí˜¸ì— ë§ëŠ” BGMì´ ìë™ìœ¼ë¡œ ì„ íƒë©ë‹ˆë‹¤.")
                    else:
                        st.warning(f"BGM í´ë”ì— ì˜¤ë””ì˜¤ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤: {BGM_DIR}")
                        use_bgm = False
                else:
                    st.warning(f"BGM í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤: {BGM_DIR}")
                    use_bgm = False

            st.markdown("---")
            
            # ---------------------------------------------------------
            # [UI] ìë§‰ ìŠ¤íƒ€ì¼ ì„ íƒ
            # ---------------------------------------------------------
            st.write(" **ìë§‰ ìŠ¤íƒ€ì¼ ì„¤ì •**")
            subtitle_mode_final = st.radio(
                "ìµœì¢… ì˜ìƒ ìë§‰ ìƒ‰ìƒ:",
                ["ğŸ³ï¸ ê¸°ë³¸ (í°ìƒ‰ í†µì¼)", "ğŸŒˆ ìºë¦­í„°ë³„ ìë™ ì»¬ëŸ¬ë§"],
                index=0,
                horizontal=True,
                key="step8_sub_mode"
            )

            st.markdown("---")

            # 2. ì‹¤í–‰ ë²„íŠ¼ (ë²„ì „ ì •ë³´ í¬í•¨)
            btn_label = f" ìµœì¢… ì˜ìƒ ìƒì„± (S{cur_s}/A{cur_a}/V{cur_v} â” Final v{next_final_ver})"
            
            if st.button(btn_label, type="primary"):
                if "proc_uid" not in st.session_state:
                    st.session_state.proc_uid = uuid.uuid4().hex[:8]
                uid = st.session_state.proc_uid
                
                # ---------------------------------------------------------
                # [í•µì‹¬] ë²„ì „ë³„ í´ë” ìƒì„± ë° ê²½ë¡œ ì§€ì •
                # ---------------------------------------------------------
                folder_name = f"v{cur_s}_{cur_a}_{cur_v}_{next_final_ver}"
                NEW_VER_DIR = FINAL_BASE_DIR / folder_name
                
                # ë‚´ë¶€ êµ¬ì¡°: clips(ìë§‰í•©ì„±ë³¸), final(ìµœì¢…ë³¸)
                SUB_DIR = NEW_VER_DIR / "clips"
                
                NEW_VER_DIR.mkdir(parents=True, exist_ok=True)
                SUB_DIR.mkdir(parents=True, exist_ok=True)
                
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                final_clips_paths = []
                total_cnt = len(video_results)

                # [ì¤‘ìš”] í‘œì§€ í˜ì´ì§€ ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸° (Step 6 ì €ì¥ê°’)
                if 'cover_page_num' in st.session_state:
                    cover_page_num = st.session_state['cover_page_num']
                elif candidates:
                    cover_page_num = candidates[0]['page_num']
                else:
                    cover_page_num = 1

                speaker_color_map = {}
                if "ì»¬ëŸ¬ë§" in subtitle_mode_final:
                    speaker_color_map = generate_dynamic_color_map(scripts)
                try:
                    for i, vid_data in enumerate(video_results):
                        # A. ë°ì´í„° ì¤€ë¹„
                        video_path = vid_data.get("trimmed")
                        if not video_path or not os.path.exists(video_path):
                            st.error(f"Scene {i+1} ì˜ìƒ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
                            continue

                        # ì˜¤ë””ì˜¤ ê²½ë¡œ
                        audio_path = audios[i].get("path") if i < len(audios) else None
                        
                        
                        # ê¸°ë³¸ ëŒ€ì‚¬ (Step 3 ê²°ê³¼)
                        script_item = scripts[i] if i < len(scripts) else {}
                        original_text = script_item.get("text", "")      # ëŒ€ì‚¬(Quote)
                        source_page = script_item.get("source_page", 0)  # í˜ì´ì§€ ë²ˆí˜¸
                        current_speaker = str(script_item.get("speaker", "narrator")).strip()
                        
                        # â˜… ìƒ‰ìƒ ê²°ì • ë¡œì§
                        if "ì»¬ëŸ¬ë§" in subtitle_mode_final:
                            text_color = speaker_color_map.get(current_speaker, "white")
                        else:
                            text_color = "white"
                        
                        subtitle_text_to_burn = original_text
                        
                        # -----------------------------------------------------------
                        # [í•µì‹¬ ë¡œì§ ë³€ê²½] ìë§‰ í…ìŠ¤íŠ¸ ê²°ì • (Context ë§¤ì¹­)
                        # -----------------------------------------------------------
                        subtitle_text_to_burn = original_text # ê¸°ë³¸ê°’: ì›ë˜ ëŒ€ì‚¬ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                        
                        """ # ëª¨ë“œê°€ 'Conversation'ì´ê³ , ë§¤ì¹­í•  1.5 ë°ì´í„°ê°€ ìˆë‹¤ë©´ ì‹¤í–‰
                        if current_mode == "Conversation" and dialogue_map:
                            found_context = None
                            
                            # dialogue_mapì—ì„œ Quoteì™€ Pageê°€ ì¼ì¹˜í•˜ëŠ” Context ì°¾ê¸°
                            for d_item in dialogue_map:
                                # ëŒ€ì‚¬ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜ í¬í•¨ë˜ì–´ ìˆê³ , í˜ì´ì§€ë„ ê°™ë‹¤ë©´ ë§¤ì¹­
                                # (strip()ìœ¼ë¡œ ê³µë°± ì œê±° í›„ ë¹„êµ)
                                if (d_item.get("quote", "").strip() == original_text.strip()) and \
                                   (d_item.get("page_num") == source_page):
                                    found_context = d_item.get("context")
                                    break
                            
                            if found_context:
                                # ë§¤ì¹­ ì„±ê³µ ì‹œ: ìë§‰ì„ Context(ìƒí™© ì„¤ëª…)ë¡œ êµì²´
                                # ì˜ˆ: ëŒ€ì‚¬ëŠ” "ì•ˆë¼!"ì§€ë§Œ ìë§‰ì€ "(ë†€ë¶€ê°€ ë°¥ì£¼ê±±ì„ íœ˜ë‘ë¥´ë©°)" ë¡œ ë‚˜ì˜´
                                subtitle_text_to_burn = f"{found_context}" 
                                # ì›í•œë‹¤ë©´ í™”ì ì´ë¦„ë„ ê°™ì´ ë„£ì„ ìˆ˜ ìˆìŒ: f"{script_item.get('speaker')}: {found_context}"
                            else:
                                # ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ: ê·¸ëƒ¥ ëŒ€ì‚¬ ì¶œë ¥ (í˜¹ì€ "ìƒí™© ì„¤ëª… ì—†ìŒ" ë“±)
                                pass  """
                                
                        # -----------------------------------------------------------

                        # ì¶œë ¥ íŒŒì¼ëª… ì •ì˜
                        output_clip_path = SUB_DIR / f"scene_{i+1:02d}_{uid}_complete.mp4"
                        
                        # 1. ìë§‰ ì…íˆê¸°                        
                        temp_sub_path = str(output_clip_path).replace(".mp4", "_temp_sub.mp4")

                        status_text.write(f" Scene {i+1}/{total_cnt}: ìë§‰ & ì˜¤ë””ì˜¤ í•©ì„± ì¤‘...")

                        add_subtitle_to_video(
                            video_path,           # 1. ì…ë ¥ ì˜ìƒ
                            subtitle_text_to_burn,# 2. ê²°ì •ëœ ìë§‰ í…ìŠ¤íŠ¸ (Context í˜¹ì€ ëŒ€ì‚¬)
                            temp_sub_path,        # 3. ì¶œë ¥ ê²½ë¡œ
                            scene_index=i,
                            font_color=text_color 
                        )

                        # 2. ì˜¤ë””ì˜¤ ì…íˆê¸° (BGM í¬í•¨) - [Step 6.5 ë¡œì§ ì ìš©]
                        audio_ok = False

                        # ìë§‰ ì˜ìƒ ìƒì„± í™•ì¸
                        if not os.path.exists(temp_sub_path):
                            st.warning(f"âš ï¸ Scene {i+1}: ìë§‰ ì˜ìƒ ìƒì„± ì‹¤íŒ¨ (temp_sub ì—†ìŒ)")
                        elif audio_path and os.path.exists(audio_path):
                            page_bgm = None

                            # BGM ê²€ìƒ‰ ë¡œì§
                            if use_bgm:
                                search_keywords = []
                                log_msg = ""

                                # Case 1: í‘œì§€ (Title)
                                if source_page == 0 or source_page == cover_page_num:
                                    search_keywords = ["title", "Title", "TITLE"]
                                    log_msg = "Title"

                                # Case 2: ë³¸ë¬¸ (nP)
                                elif source_page > cover_page_num:
                                    story_seq = source_page - cover_page_num + 1
                                    search_keywords = [f"{story_seq}p", f"{story_seq}P", f"Page {story_seq}", f"Page{story_seq}"]
                                    log_msg = f"{story_seq}p"

                                if search_keywords:
                                    page_bgm = find_bgm_file(search_keywords, BGM_DIR)

                            # BGMì´ ìˆìœ¼ë©´ TTS+BGM ì‹œë„
                            if page_bgm and page_bgm.exists():
                                audio_ok = add_audio_to_video(
                                    temp_sub_path,
                                    str(audio_path),
                                    str(output_clip_path),
                                    bgm_path=str(page_bgm),
                                    bgm_volume=bgm_volume
                                )
                                if audio_ok is True:
                                    st.caption(f"ğŸµ Scene {i+1}: BGM '{page_bgm.name}' ({log_msg}) ì ìš©")

                            # BGMì´ ì—†ê±°ë‚˜ BGM+TTS ì‹¤íŒ¨ â†’ TTSë§Œ ì ìš©
                            if audio_ok is not True:
                                audio_ok = add_audio_to_video(
                                    temp_sub_path,
                                    str(audio_path),
                                    str(output_clip_path)
                                )
                                if audio_ok is True:
                                    if use_bgm:
                                        st.caption(f"Scene {i+1}: BGM ì—†ìŒ, TTSë§Œ ì ìš© (Source: {source_page}p)")
                                else:
                                    st.warning(f"âš ï¸ Scene {i+1}: TTS í•©ì„± ì‹¤íŒ¨ - {audio_ok}")
                        else:
                            st.caption(f"Scene {i+1}: TTS íŒŒì¼ ì—†ìŒ (audio_path={audio_path})")

                        # ì˜¤ë””ì˜¤ í•©ì„± ì‹¤íŒ¨ ì‹œ â†’ ìë§‰ë§Œ ì…íŒ ì˜ìƒ ì‚¬ìš©
                        if not audio_ok:
                            if os.path.exists(temp_sub_path):
                                shutil.copy2(temp_sub_path, str(output_clip_path))

                        # ì„ì‹œ íŒŒì¼ ì •ë¦¬
                        if os.path.exists(temp_sub_path) and temp_sub_path != str(output_clip_path):
                            os.remove(temp_sub_path)

                        # í´ë¦½ íŒŒì¼ ì¶”ê°€
                        if os.path.exists(str(output_clip_path)) and os.path.getsize(str(output_clip_path)) > 0:
                            final_clips_paths.append(str(output_clip_path))
                        else:
                            st.warning(f"âš ï¸ Scene {i+1} í´ë¦½ ìƒì„± ì‹¤íŒ¨ - ê±´ë„ˆëœë‹ˆë‹¤.")
                        progress_bar.progress((i + 1) / total_cnt)

                    # 3. ì „ì²´ ì´ì–´ë¶™ì´ê¸°
                    if final_clips_paths:
                        status_text.write(" ìµœì¢… í•©ì²´ ì¤‘...")
                        # ìµœì¢… íŒŒì¼ë„ NEW_VER_DIR ì•ˆì— ì €ì¥
                        final_movie_path = NEW_VER_DIR / f"final_movie_{uid}.mp4"

                        concat_result = concat_videos_with_audio(final_clips_paths, str(final_movie_path))

                        if concat_result is True and os.path.exists(str(final_movie_path)):
                            # [Manifest] ì €ì¥
                            manifest = {
                                "version_info": {"s": cur_s, "a": cur_a, "v": cur_v, "f": next_final_ver},
                                "created_at": str(datetime.now()),
                                "bgm_used": use_bgm,
                                "bgm_volume": bgm_volume,
                                "final_movie_path": str(final_movie_path),
                                "clips": final_clips_paths
                            }
                            with open(NEW_VER_DIR / "manifest.json", "w", encoding="utf-8") as f:
                                json.dump(manifest, f, ensure_ascii=False, indent=4)

                            # ì„¸ì…˜ ê°±ì‹ 
                            st.session_state.track_b_final_movie = str(final_movie_path)
                            st.session_state[f"loaded_final_dir_{current_mode}"] = str(NEW_VER_DIR)

                            st.success(f" ìµœì¢… ì˜ìƒ ì™„ì„±! (Ver. {next_final_ver})")
                            status_text.empty()

                            # ì¦‰ì‹œ ì˜ìƒ í‘œì‹œ (ë²„íŠ¼ ë¸”ë¡ ë‚´ì—ì„œ)
                            st.video(str(final_movie_path))
                            with open(str(final_movie_path), "rb") as dl_f:
                                st.download_button(
                                    label="ğŸ’¾ ìµœì¢… ì˜ìƒ ë‹¤ìš´ë¡œë“œ (.mp4)",
                                    data=dl_f,
                                    file_name=f"{txt_file.stem}_final_v{next_final_ver}.mp4",
                                    mime="video/mp4",
                                    key="step8_immediate_download"
                                )
                        else:
                            error_detail = concat_result if isinstance(concat_result, str) else "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"
                            st.error(f"ìµœì¢… ì˜ìƒ í•©ì¹˜ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {error_detail}")
                            status_text.empty()

                except Exception as e:
                    st.error(f"ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

            # 3. ê²°ê³¼ í™•ì¸ ë° ë‹¤ìš´ë¡œë“œ
            if st.session_state.get("track_b_final_movie") and os.path.exists(st.session_state.track_b_final_movie):
                st.divider()
                # ë²„ì „ ë¼ë²¨ í‘œì‹œ
                if selected_key:
                    s, a, v, f = selected_key
                    ver_display = f"S{s}/A{a}/V{v}/F{f}"
                else:
                    ver_display = f"S{cur_s}/A{cur_a}/V{cur_v}/F{next_final_ver-1}"

                st.markdown(f"### ğŸ¿ ìµœì¢… ì™„ì„±ë³¸ ë¯¸ë¦¬ë³´ê¸° ({ver_display})")

                st.session_state.current_final_ver = next_final_ver

                final_path = st.session_state.track_b_final_movie
                st.video(final_path)
                
                col_d1, col_d2 = st.columns(2)
                with col_d1:
                    with open(final_path, "rb") as f:
                        st.download_button(
                            label="ğŸ’¾ ìµœì¢… ì˜ìƒ ë‹¤ìš´ë¡œë“œ (.mp4)",
                            data=f,
                            file_name=f"{txt_file.stem}_final_v{ver_display}.mp4",
                            mime="video/mp4",
                            type="primary"
                        )
                with col_d2:
                    if st.button("ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ë§Œë“¤ê¸° (ìƒˆë¡œê³ ì¹¨)"):
                        st.session_state.clear()
                        st.rerun()